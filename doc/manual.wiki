= Name =

ngx_lua - Embed the Power of Lua into Nginx

= Status =

This module is under active development and is already production ready :)

We're already using this module very heavily in our production web applications
here in Taobao.com, Alibaba Group.

= Synopsis =
<geshi lang="nginx">
    # set search paths for pure Lua external libraries (';;' is the default path):
    lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
 
    # set search paths for Lua external libraries written in C (can also use ';;'):
    lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
 
    server {
        location /inline_concat {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            set $a "hello";
            set $b "world";
            # inline lua script
            set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
            echo $res;
        }
 
        location /rel_file_concat {
            set $a "foo";
            set $b "bar";
            # script path relative to nginx prefix
            # $ngx_prefix/conf/concat.lua contents:
            #
            #    return ngx.arg[1]..ngx.arg[2]
            #
            set_by_lua_file $res conf/concat.lua $a $b;
            echo $res;
        }
 
        location /abs_file_concat {
            set $a "fee";
            set $b "baz";
            # absolute script path not modified
            set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
            echo $res;
        }
 
        location /lua_content {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua "ngx.say('Hello,world!')"
        }
 
         location /nginx_var {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            # try access /nginx_var?a=hello,world
            content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
        }
 
        location /request_body {
             # force reading request body (default off)
             lua_need_request_body on;
             client_max_body_size 50k;
             client_body_buffer_size 50k;
 
             content_by_lua 'ngx.print(ngx.var.request_body)';
        }
 
        # transparent non-blocking I/O in Lua via subrequests
        location /lua {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
                local res = ngx.location.capture("/some_other_location")
                if res.status == 200 then
                    ngx.print(res.body)
                end';
        }
 
        # GET /recur?num=5
        location /recur {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
               local num = tonumber(ngx.var.arg_num) or 0
               ngx.say("num is: ", num)
 
               if num > 0 then
                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
                   ngx.print("status=", res.status, " ")
                   ngx.print("body=", res.body)
               else
                   ngx.say("end")
               end
               ';
        }
 
        location /foo {
            rewrite_by_lua '
                res = ngx.location.capture("/memc",
                    { args = { cmd = 'incr', key = ngx.var.uri } }
                )
            ';
 
            proxy_pass http://blah.blah.com;
        }
 
        location /blah {
            access_by_lua '
                local res = ngx.location.capture("/auth")
 
                if res.status == ngx.HTTP_OK then
                    return
                end
 
                if res.status == ngx.HTTP_FORBIDDEN then
                    ngx.exit(res.status)
                end
 
                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            ';
 
            # proxy_pass/fastcgi_pass/postgres_pass/...
        }
 
        location /mixed {
            rewrite_by_lua_file /path/to/rewrite.lua;
            access_by_lua_file /path/to/access.lua;
            content_by_lua_file /path/to/content.lua;
        }
 
        # use nginx var in code path
        # WARN: contents in nginx var must be carefully filtered,
        # otherwise there'll be great security risk!
        location ~ ^/app/(.+) {
                content_by_lua_file /path/to/lua/app/root/$1.lua;
        }
 
        location / {
           lua_need_request_body on;
 
           client_max_body_size 100k;
           client_body_buffer_size 100k;
 
           access_by_lua '
               -- check the client IP addr is in our black list
               if ngx.var.remote_addr == "132.5.72.3" then
                   ngx.exit(ngx.HTTP_FORBIDDEN)
               end
 
               -- check if the request body contains bad words
               if ngx.var.request_body and
                        string.match(ngx.var.request_body, "fsck")
               then
                   return ngx.redirect("/terms_of_use.html")
               end
 
               -- tests passed
           ';
 
           # proxy_pass/fastcgi_pass/etc settings
        }
    }
</geshi>
= Description =

This module embeds the Lua interpreter or LuaJIT into the nginx core and integrates the powerful Lua threads (aka Lua coroutines) into the nginx event model
by means of nginx subrequests.

Unlike Apache's mod_lua and Lighttpd's mod_magnet, Lua code written atop this module can be 100% non-blocking on network traffic
as long as you use the [[#ngx.location.capture|ngx.location.capture]] or
[[#ngx.location.capture_multi|ngx.location.capture_multi]] interfaces
to let the nginx core do all your
requests to mysql, postgresql, memcached,
upstream http web services, and etc etc etc (see
ngx_drizzle, ngx_postgres, ngx_memc, and ngx_proxy modules for details).

The Lua interpreter instance is shared across all
the requests in a single nginx worker process.

Request contexts are isolated from each other
by means of Lua (lightweight) threads (aka Lua coroutines).
And Lua modules loaded are persistent on
the nginx worker process level. So the memory
footprint is quite small even when your
nginx worker process is handling 10K requests at the same time.

= Directives =

== lua_code_cache ==
'''syntax:''' ''lua_code_cache on | off''

'''default:''' ''lua_code_cache on''

'''context:''' ''main, server, location, location if''

Enable or disable the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.

The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
and [[#rewrite_by_lua_file|rewrite_by_lua_file]] won't be cached at all,
and Lua's <code>package.loaded</code> table will be cleared
at every request's entry point (such that Lua modules
won't be cached either). So developers and enjoy
the PHP-way, i.e., edit-and-refresh.

But please note that Lua code inlined into nginx.conf
like those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
cached because only nginx knows how to parse <code>nginx.conf</code>
and the only way to tell it to re-load the config file
is to send a <code>HUP</code> signal to it or just to restart it from scratch.

For now, ngx_lua does not support the "stat" mode like
Apache's <code>mod_lua</code>, but we will work on it in the future.

Disabling the Lua code cache is mainly used for Lua
development only because it has great
impact on the over-all performance and is strongly
discouraged for production uses. Also, race conditions
when reloading Lua modules are common for concurrent requests
when the code cache is off.

== lua_package_path ==

'''syntax:''' ''lua_package_path <lua-style-path-str>''

'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''

'''context:''' ''main''

Set the Lua module searching path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The path string is in standard Lua path form, and <code>;;</code>
can be used to stand for the original path.

== lua_package_cpath ==

'''syntax:''' ''lua_package_cpath <lua-style-cpath-str>''

'''default:''' ''The content of LUA_CPATH environ variable or Lua's compiled-in''

defaults.
'''context:''' ''main''

Set the Lua C-module searching path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The cpath string is in standard Lua cpath form, and <code>;;</code>
can be used to stand for the original cpath.

== set_by_lua ==

'''syntax:''' ''set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

Execute user code specified by <code><lua-script-str></code> with input arguments <code>$arg1 $arg2 ...</code>, and set the script's return value to <code>$res</code> in string form. In
<code><lua-script-str></code> code the input arguments can be retrieved from <code>ngx.arg</code>
table (index starts from <code>1</code> and increased sequentially).

[[#set_by_lua|set_by_lua]] directives are designed to execute small and quick codes. Nginx
event loop is blocked during the code execution, so you'd better '''NOT''' call
anything that may be blocked or time-costy.

Note that [[#set_by_lua|set_by_lua]] can only output a value to a single nginx variable at
a time. But a work-around is also available by means of the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface,
for example,
<geshi lang="nginx">
    location /foo {
        set $diff ''; # we have to predefine the $diff variable here
 
        set_by_lua $sum '
            local a = 32
            local b = 56
 
            ngx.var.diff = a - b;  -- write to $diff directly
            return a + b;          -- return the $sum value normally
        ';
 
        echo "sum = $sum, diff = $diff";
    }
</geshi>
This directive requires the ngx_devel_kit module.

== set_by_lua_file ==

'''syntax:''' ''set_by_lua_file $res <path-to-lua-script> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

Basically the same as [[#set_by_lua|set_by_lua]], except the code to be executed is in the
file specified by <code><path-lua-script></code>.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting <code>lua_code_cache off;</code> in your nginx.conf.

This directive requires the ngx_devel_kit module.

== content_by_lua ==

'''syntax:''' ''content_by_lua <lua-script-str>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Act as a content handler and execute user code specified by <code><lua-script-str></code>
for every request. The user code may call predefined APIs to generate response
content.

The use code is executed in a new spawned coroutine with independent globals
environment (i.e. a sandbox). I/O operations in user code should only be done
through predefined Nginx APIs, otherwise Nginx event loop may be blocked and
performance may drop off dramatically.

As predefined Nginx I/O APIs used coroutine yielding/resuming mechanism, the
user code should not call any modules that used coroutine API to prevent
obfuscating the predefined Nginx APIs (actually coroutine module is masked off
in [[#content_by_lua|content_by_lua]] directives). This limitation is a little crucial, but
don't worry! We're working on a alternative coroutine implementation that can
be fit in the Nginx event framework. When it is done, the user code will be
able to use coroutine mechanism freely as in standard Lua again!

== rewrite_by_lua ==

'''syntax:''' ''rewrite_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Act as a rewrite phase handler and execute user code specified by <code><lua-script-str></code>
for every request. The user code may call predefined APIs to generate response
content.

This hook uses exactly the same mechamism as [[#content_by_lua|content_by_lua]] so all the nginx APIs defined there
are also available here.

Note that this handler always runs ''after'' the standard nginx rewrite module ( http://wiki.nginx.org/NginxHttpRewriteModule ). So the following will work as expected:
<geshi lang="nginx">
   location /foo {
       set $a 12; # create and initialize $a
       set $b ''; # create and initialize $b
       rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
       echo "res = $b";
   }
</geshi>
because <code>set $a 12</code> and <code>set $b ''</code> run before [[#rewrite_by_lua|rewrite_by_lua]].

On the other hand, the following will not work as expected:
<geshi lang="nginx">
    ?  location /foo {
    ?      set $a 12; # create and initialize $a
    ?      set $b ''; # create and initialize $b
    ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
    ?      if ($b = '13') {
    ?         rewrite ^ /bar redirect;
    ?         break;
    ?      }
    ?
    ?      echo "res = $b";
    ?  }
</geshi>
because <code>if</code> runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it's put after [[#rewrite_by_lua|rewrite_by_lua]] in the config.

The right way of doing this is as follows:
<geshi lang="nginx">
    location /foo {
        set $a 12; # create and initialize $a
        set $b ''; # create and initialize $b
        rewrite_by_lua '
            ngx.var.b = tonumber(ngx.var.a) + 1
            if ngx.var.b == 13 then
                return ngx.redirect("/bar");
            end
        ';
 
        echo "res = $b";
    }
</geshi>
It's worth mentioning that, the <code>ngx_eval</code> module can be
approximately implemented by [[#rewrite_by_lua|rewrite_by_lua]]. For example,
<geshi lang="nginx">
    location / {
        eval $res {
            proxy_pass http://foo.com/check-spam;
        }
 
        if ($res = 'spam') {
            rewrite ^ /terms-of-use.html redirect;
        }
 
        fastcgi_pass ...;
    }
</geshi>
can be implemented in terms of <code>ngx_lua</code> like this
<geshi lang="nginx">
    location = /check-spam {
        internal;
        proxy_pass http://foo.com/check-spam;
    }
 
    location / {
        rewrite_by_lua '
            local res = ngx.location.capture("/check-spam")
            if res.body == "spam" then
                ngx.redirect("/terms-of-use.html")
            end
        ';
 
        fastcgi_pass ...;
    }
</geshi>
Just as any other rewrite-phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.

Note that calling <code>ngx.exit(ngx.OK)</code> just returning from the current [[#rewrite_by_lua|rewrite_by_lua]] handler, and the nginx request processing
control flow will still continue to the content handler. To terminate the current request from within the current [[#rewrite_by_lua|rewrite_by_lua]] handler,
calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.

== access_by_lua ==

'''syntax:''' ''access_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Act as an access phase handler and execute user code specified by <code><lua-script-str></code>
for every request. The user code may call predefined APIs to generate response
content.

This hook uses exactly the same mechamism as [[#content_by_lua|content_by_lua]]
so all the nginx APIs defined there
are also available here.

Note that this handler always runs ''after'' the standard nginx
access module ( http://wiki.nginx.org/NginxHttpAccessModule ).
So the following will work as expected:
<geshi lang="nginx">
    location / {
        deny    192.168.1.1;
        allow   192.168.1.0/24;
        allow   10.1.1.0/16;
        deny    all;
 
        access_by_lua '
            local res = ngx.location.capture("/mysql", { ... })
            ...
        ';
 
        # proxy_pass/fastcgi_pass/...
    }
</geshi>
That is, if a client address appears in the blacklist, then
we don't have to bother sending a mysql query to do more
advanced authentication in [[#access_by_lua|access_by_lua]].

It's worth mentioning that, the <code>ngx_auth_request</code> module can be
approximately implemented by [[#access_by_lua|access_by_lua]]. For example,
<geshi lang="nginx">
    location / {
        auth_request /auth;
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>
can be implemented in terms of <code>ngx_lua</code> like this
<geshi lang="nginx">
    location / {
        access_by_lua '
            local res = ngx.location.capture("/auth")
 
            if res.status == ngx.HTTP_OK then
                return
            end
 
            if res.status == ngx.HTTP_FORBIDDEN then
                ngx.exit(res.status)
            end
 
            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        ';
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>
Just as any other access-phase handlers, [[#access_by_lua|access_by_lua]] will NOT run in subrequests.

Note that calling <code>ngx.exit(ngx.OK)</code> just returning from the current [[#access_by_lua|access_by_lua]] handler, and the nginx request processing
control flow will still continue to the content handler. To terminate the current request from within the current [[#access_by_lua|access_by_lua]] handler,
calling <code>ngx.exit(status)</code> where status >= 200 (ngx.HTTP_OK) and status < 300 (ngx.HTTP_SPECIAL_RESPONSE) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> or its friends for failures.

== content_by_lua_file ==

'''syntax:''' ''content_by_lua_file <path-to-lua-script>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Basically the same as [[#content_by_lua|content_by_lua]], except the code to be executed is in
the file specified by <code><path-lua-script></code>.

Nginx variables can be used in <path-to-lua-script> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting <code>lua_code_cache off;</code> in your nginx.conf.

== rewrite_by_lua_file ==

'''syntax:''' ''rewrite_by_lua_file <path-to-lua-script>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Same as [[#rewrite_by_lua|rewrite_by_lua]], except the code to be executed is in
the file specified by <code><path-lua-script></code>.

Nginx variables can be used in <path-to-lua-script> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting <code>lua_code_cache off;</code> in your nginx.conf.

== access_by_lua_file ==

'''syntax:''' ''access_by_lua_file <path-to-lua-script>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Same as [[#access_by_lua|access_by_lua]], except the code to be executed is in the file
specified by <code><path-lua-script></code>.

Nginx variables can be used in <path-to-lua-script> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting <code>lua_code_cache off;</code> in your nginx.conf.

== lua_need_request_body ==

'''syntax:''' ''lua_need_request_body <on | off>''

'''default:''' ''off''

'''context:''' ''main | server | location''

'''phase:''' ''depends on usage''

Force reading request body data or not. The client request body won't be read,
so you have to explicitly force reading the body if you need its content.

If you want to read the request body data from the <code>$request_body</code> variable, make sure that
your have configured <code>client_body_buffer_size</code> to have exactly the same value as <code>client_max_body_size</code>. See

http://wiki.nginx.org/HttpCoreModule#client_body_buffer_size 

for more details.

If the current location defines [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]],
then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
<code>rewrite</code> phase). Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
the request body won't be read until the content handler's Lua code is
about to run (i.e., the request body will be read at the
content phase).

The same applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].

= Nginx API for Lua =

== Input arguments ==
'''context:''' ''set_by_lua*''

Index the input arguments to the set_by_lua* directives:
<geshi lang="nginx">
    value = ngx.arg[n]
</geshi>
Here's an example
<geshi lang="nginx">
    location /foo {
        set $a 32;
        set $b 56;
 
        set_by_lua $res
            'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
            $a $b;
 
        echo $sum;
    }
</geshi>
that outputs 88, the sum of 32 and 56.

== ngx.var.VARIABLE ==
'''syntax:''' ''ngx.var.VAR_NAME''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
<geshi lang="nginx">
    value = ngx.var.some_nginx_variable_name
    ngx.var.some_nginx_variable_name = value
</geshi>
Note that you can only write to nginx variables that are already defined.
For example:
<geshi lang="nginx">
    location /foo {
        set $my_var ''; # this line is required to create $my_var at config time
        content_by_lua '
            ngx.var.my_var = 123;
            ...
        ';
    }
</geshi>
That is, nginx variables cannot be created on-the-fly.

Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value,
some are not, like <code>$arg_PARAMETER</code>.

Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this
interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.

== Core constants ==
'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
<geshi lang="nginx">
  ngx.OK
  ngx.DONE
  ngx.AGAIN
  ngx.ERROR
</geshi>
They take the same values of <code>NGX_OK</code>, <code>NGX_AGAIN</code>, <code>NGX_DONE</code>, <code>NGX_ERROR</code>, and etc. But now
only [[#ngx.exit|ngx.exit]] only take two of these values, i.e., <code>NGX_OK</code> and <code>NGX_ERROR</code>.

== HTTP method constants ==
'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
<geshi lang="nginx">
  value = ngx.HTTP_GET
  value = ngx.HTTP_HEAD
  value = ngx.HTTP_PUT
  value = ngx.HTTP_POST
  value = ngx.HTTP_DELETE
</geshi>
== HTTP status constants ==
'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''
<geshi lang="nginx">
  value = ngx.HTTP_OK (200)
  value = ngx.HTTP_CREATED (201)
  value = ngx.HTTP_SPECIAL_RESPONSE (300)
  value = ngx.HTTP_MOVED_PERMANENTLY (301)
  value = ngx.HTTP_MOVED_TEMPORARILY (302)
  value = ngx.HTTP_SEE_OTHER (303)
  value = ngx.HTTP_NOT_MODIFIED (304)
  value = ngx.HTTP_BAD_REQUEST (400)
  value = ngx.HTTP_UNAUTHORIZED (401)
  value = ngx.HTTP_FORBIDDEN (403)
  value = ngx.HTTP_NOT_FOUND (404)
  value = ngx.HTTP_NOT_ALLOWED (405)
  value = ngx.HTTP_GONE (410)
  value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
  value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
</geshi>
== Nginx log level constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''
<geshi lang="nginx">
  log_level = ngx.STDERR
  log_level = ngx.EMERG
  log_level = ngx.ALERT
  log_level = ngx.CRIT
  log_level = ngx.ERR
  log_level = ngx.WARN
  log_level = ngx.NOTICE
  log_level = ngx.INFO
  log_level = ngx.DEBUG
</geshi>
== print ==
'''syntax:''' ''print(...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Emit args concatenated to <code>error.log</code>, with log level <code>ngx.NOTICE</code> and prefix <code>lua print: </code>.

It's equivalent to
<geshi lang="nginx">
    ngx.log(ngx.NOTICE, 'lua print: ', a, b, ...)
</geshi>
Lua nil arguments are accepted and result in literal "nil", and Lua booleans result in "true" or "false".

== ngx.ctx ==
'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This table can be used to store per-request context data for Lua programmers.

This table has a liftime identical to the current request (just like Nginx variables). Consider the following example,
<geshi lang="nginx">
    location /test {
        rewrite_by_lua '
            ngx.say("foo = ", ngx.ctx.foo)
            ngx.ctx.foo = 76
        ';
        access_by_lua '
            ngx.ctx.foo = ngx.ctx.foo + 3
        ';
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
</geshi>
Then <code>GET /test</code> will yield the output
<geshi lang="nginx">
    foo = nil
    79
</geshi>
That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.

Also, every request has its own copy, include subrequests, for example:
<geshi lang="nginx">
    location /sub {
        content_by_lua '
            ngx.say("sub pre: ", ngx.ctx.blah)
            ngx.ctx.blah = 32
            ngx.say("sub post: ", ngx.ctx.blah)
        ';
    }
 
    location /main {
        content_by_lua '
            ngx.ctx.blah = 73
            ngx.say("main pre: ", ngx.ctx.blah)
            local res = ngx.location.capture("/sub")
            ngx.print(res.body)
            ngx.say("main post: ", ngx.ctx.blah)
        ';
    }
</geshi>
Then <code>GET /main</code> will give the output
<geshi lang="nginx">
    main pre: 73
    sub pre: nil
    sub post: 32
    main post: 73
</geshi>
We can see that modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in its parent request. They do have two separate versions of <code>ngx.ctx.blah</code> per se.

Internal redirection will destroy the original request's <code>ngx.ctx</code> data (if any) and the new request will have an emptied <code>ngx.ctx</code> table. For instance,
<geshi lang="nginx">
    location /new {
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
 
    location /orig {
        content_by_lua '
            ngx.ctx.foo = "hello"
            ngx.exec("/new")
        ';
    }
</geshi>
Then <code>GET /orig</code> will give you
<geshi lang="nginx">
    nil
</geshi>
rather than the original <code>"hello"</code> value.

Arbitrary data values can be inserted into this "matic" table, including Lua closures and nested tables. You can also register your own meta methods with it.

Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,
<geshi lang="nginx">
    ngx.ctx = { foo = 32, bar = 54 }
</geshi>
== ngx.location.capture ==
'''syntax:''' ''res = ngx.location.capture(uri, options?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue a synchronous but still non-blocking "nginx subrequest" using <code>uri</code>.

Nginx subrequests provide a powerful way to make
non-blocking internal requests to other locations
configured with disk file directory or ''any''
other nginx C modules like
<code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>,
<code>ngx_postgres</code>,
<code>ngx_drizzle</code>, and even <code>ngx_lua</code> itself and etc etc etc.

Also note that subrequests just mimic the HTTP
interface but there's ''no''
extra HTTP/TCP traffic ''nor'' IPC involved. Everything
works internally, efficiently, on the C level.

Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).

Here's a basic example:
<geshi lang="nginx">
    res = ngx.location.capture(uri)
</geshi>
Returns a Lua table with three slots (<code>res.status</code>, <code>res.header</code>, and <code>res.body</code>).

<code>res.header</code> holds all the response headers of the
subrequest and it is a normal Lua table. For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear. For instance, if the subrequest response headers contains the following
lines:
<geshi lang="nginx">
    Set-Cookie: a=3
    Set-Cookie: foo=bar
    Set-Cookie: baz=blah
</geshi>
Then <code>res.header["Set-Cookie"]</code> will be evaluted to the table value
<code>{"a=3", "foo=bar", "baz=blah"}</code>.

URI query strings can be concatenated to URI itself, for instance,
<geshi lang="nginx">
    res = ngx.location.capture('/foo/bar?a=3&b=4')
</geshi>
Named locations like <code>@foo</code> are not allowed due to a limitation in
the nginx core. Use normal locations combined with the <code>internal</code> directive to
prepare internal-only locations.

An optional option table can be fed as the second
argument, which support various options like
<code>method</code>, <code>body</code>, <code>args</code>, and <code>share_all_vars</code>.
Issuing a POST subrequest, for example,
can be done as follows
<geshi lang="nginx">
    res = ngx.location.capture(
        '/foo/bar',
        { method = ngx.HTTP_POST, body = 'hello, world' }
    )
</geshi>
See HTTP method constants methods other than POST.
The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.

The <code>share_all_vars</code> option can control whether to share nginx variables
among the current request and the new subrequest. If this option is set to <code>true</code>, then
the subrequest can see all the variable values of the current request while the current
requeset can also see any variable value changes made by the subrequest.
Note that variable sharing can have unexpected side-effects
and lead to confusing issues, use it with special
care. So, by default, the option is set to <code>false</code>.

The <code>args</code> option can specify extra url arguments, for instance,
<geshi lang="nginx">
    ngx.location.capture('/foo?a=1',
        { args = { b = 3, c = ':' } }
    )
</geshi>
is equivalent to
<geshi lang="nginx">
    ngx.location.capture('/foo?a=1&b=3&c=%3a')
</geshi>
that is, this method will autmotically escape argument keys and values according to URI rules and
concatenating them together into a complete query string. Because it's all done in hand-written C,
it should be faster than your own Lua code.

The <code>args</code> option can also take plain query string:
<geshi lang="nginx">
    ngx.location.capture('/foo?a=1',
        { args = 'b=3&c=%3a' } }
    )
</geshi>
This is functionally identical to the previous examples.

Note that, by default, subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
request headers of the current request. This may have unexpected side-effects on the
subrequest responses. For example, when you're using the standard <code>ngx_proxy</code> module to serve
your subrequests, then an "Accept-Encoding: gzip" header in your main request may result
in gzip'd responses that your Lua code is not able to handle properly. So always set
<code>proxy_pass_request_headers off</code> in your subrequest location to ignore the original request headers.
See http://wiki.nginx.org/NginxHttpProxyModule#proxy_pass_request_headers for more
details.

== ngx.location.capture_multi ==
'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.

This function issue several parallel subrequests specified by the input table, and returns their results in the same order. For example,
<geshi lang="nginx">
    res1, res2, res3 = ngx.location.capture_multi{
        { "/foo", { args = "a=3&b=4" } },
        { "/bar" },
        { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
    }
 
    if res1.status == ngx.HTTP_OK then
        ...
    end
 
    if res2.body == "BLAH" then
        ...
    end
</geshi>
This function will not return until all the subrequests terminate.
The total latency is the longest latency of the subrequests, instead of their sum.

When you don't know inadvance how many subrequests you want to issue,
you can use Lua tables for both requests and responses. For instance,
<geshi lang="nginx">
    -- construct the requests table
    local reqs = {}
    table.insert(reqs, { "/mysql" })
    table.insert(reqs, { "/postgres" })
    table.insert(reqs, { "/redis" })
    table.insert(reqs, { "/memcached" })
 
    -- issue all the requests at once and wait until they all return
    local resps = { ngx.location.capture_multi(reqs) }
 
    -- loop over the responses table
    for i, resp in ipairs(resps) do
        -- process the response table "resp"
    end
</geshi>
The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
of this function. Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this
<geshi lang="nginx">
    ngx.location.capture =
        function (uri, args)
            return ngx.location.capture_multi({ {uri, args} })
        end
</geshi>
== ngx.status ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Read and write the current request's response status. This should be called
before sending out the response headers.
<geshi lang="nginx">
    ngx.status = ngx.HTTP_CREATED
    status = ngx.status
</geshi>
== ngx.header.HEADER ==
'''syntax:''' ''ngx.header.HEADER = VALUE''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Set/add/clear the current request's response headers. Underscores (_) in the header names will be replaced by dashes (-) and the header names will be matched case-insentively.
<geshi lang="nginx">
    -- equivalent to ngx.header["Content-Type"] = 'text/plain'
    ngx.header.content_type = 'text/plain';
 
    ngx.header["X-My-Header"] = 'blah blah';
</geshi>
Multi-value headers can be set this way:
<geshi lang="nginx">
    ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
</geshi>
will yield
<geshi lang="nginx">
    Set-Cookie: a=32; path=/
    Set-Cookie: b=4; path=/
</geshi>
in the response headers. Only array-like tables are accepted.

Note that, for those standard headers that only accepts a single value, like Content-Type, only the last element
in the (array) table will take effect. So
<geshi lang="nginx">
    ngx.header.content_type = {'a', 'b'}
</geshi>
is equivalent to
<geshi lang="nginx">
    ngx.header.content_type = 'b'
</geshi>
Setting a slot to nil effectively removes it from the response headers:
<geshi lang="nginx">
    ngx.header["X-My-Header"] = nil;
</geshi>
same does assigning an empty table:
<geshi lang="nginx">
    ngx.header["X-My-Header"] = {};
</geshi>
<code>ngx.header</code> is not a normal Lua table so you cannot
iterate through it.

For reading request headers, use the <code>ngx.req.get_headers()</code> function instead.

Reading values from ngx.header.HEADER is not implemented yet,
and usually you shouldn't need it.

== ngx.req.get_uri_args ==
'''syntax:''' ''args = ngx.req.get_uri_args()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a Lua table holds all of the current request's request URL query arguments.

Here's an example,
<geshi lang="nginx">
    location = /test {
        content_by_lua '
            local args = ngx.req.get_uri_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>
Then <code>GET /test?foo=bar&bar=baz&bar=blah</code> will yield the response body
<geshi lang="nginx">
    foo: bar
    bar: baz, blah
</geshi>
Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be automatically unescaped according to URI escaping rules. For example, in the above settings, <code>GET /test?a%20b=1%61+2</code> will yield the output
<geshi lang="nginx">
    a b: 1a 2
</geshi>
Arguments without the <code>=<value></code> parts are treated as boolean arguments. For example, <code>GET /test?foo&bar</code> will yield the outputs
<geshi lang="nginx">
    foo: true
    bar: true
</geshi>
That is, they will take Lua boolean values <code>true</code>. However, they're different from arguments taking empty string values. For example, <code>GET /test?foo=&bar=</code> will give something like
<geshi lang="nginx">
    foo: 
    bar: 
</geshi>
Empty key arguments are discarded, for instance, <code>GET /test?=hello&=world</code> will yield empty outputs.

Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime are also supported:
<geshi lang="nginx">
    ngx.var.args = "a=3&b=42"
    local args = ngx.req.get_uri_args()
</geshi>
Here the <code>args</code> table will always look like
<geshi lang="nginx">
    {a = 3, b = 42}
</geshi>
regardless of the actual request query string.

== ngx.req.get_post_args ==
'''syntax:''' ''ngx.req.get_post_args()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a Lua table holds all of the current request's POST query arguments. It's required to turn on the [[#lua_need_request_body|lua_need_request_body]] directive, or a Lua exception will be thrown.

Here's an example,
<geshi lang="nginx">
    location = /test {
        lua_need_request_body on;
        content_by_lua '
            local args = ngx.req.get_post_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>
Then
<geshi lang="nginx">
    # Post request with the body 'foo=bar&bar=baz&bar=blah'
    $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
</geshi>
will yield the response body like
<geshi lang="nginx">
    foo: bar
    bar: baz, blah
</geshi>
Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be automatically unescaped according to URI escaping rules. For example, in the above settings,
<geshi lang="nginx">
    # POST request with body 'a%20b=1%61+2'
    $ curl -d 'a%20b=1%61+2' localhost/test
</geshi>
will yield the output
<geshi lang="nginx">
    a b: 1a 2
</geshi>
Arguments without the <code>=<value></code> parts are treated as boolean arguments. For example, <code>GET /test?foo&bar</code> will yield the outputs
<geshi lang="nginx">
    foo: true
    bar: true
</geshi>
That is, they will take Lua boolean values <code>true</code>. However, they're different from arguments taking empty string values. For example, <code>POST /test</code> with request body <code>foo=&bar=</code> will give something like
<geshi lang="nginx">
    foo: 
    bar: 
</geshi>
Empty key arguments are discarded, for instance, <code>POST /test</code> with body <code>=hello&=world</code> will yield empty outputs.

== ngx.req.get_headers ==
'''syntax:''' ''headers = ngx.req.get_headers()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a Lua table holds all of the current request's request headers.

Here's an example,
<geshi lang="nginx">
    local h = ngx.req.get_headers()
    for k, v in pairs(h) do
        ...
    end
</geshi>
To read an individual header:
<geshi lang="nginx">
    ngx.say("Host: ", ngx.req.get_headers()["Host"])
</geshi>
For multiple instances of request headers like
<geshi lang="nginx">
    Foo: foo
    Foo: bar
    Foo: baz
</geshi>
the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua (array) table like this:
<geshi lang="nginx">
    {"foo", "bar", "baz"}
</geshi>
Another way to read individual request headers is to use <code>ngx.var.http_HEADER</code>, that is, nginx's standard <code>$http_HEADER</code> variables:

http://wiki.nginx.org/NginxHttpCoreModule#.24http_HEADER

== ngx.req.set_header ==
'''syntax:''' ''ngx.req.set_header(header_name, header_value)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Set the current request's request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.
None of the current request's subrequests will be affected.

Here's an example of setting the <code>Content-Length</code> header:
<geshi lang="nginx">
    ngx.req.set_header("Content-Type", "text/css")
</geshi>
The <code>header_value</code> can take an array list of values,
for example,
<geshi lang="nginx">
    ngx.req.set_header("Foo", {"a", "abc"})
</geshi>
will produce two new request headers:
<geshi lang="nginx">
    Foo: a
    Foo: abc
</geshi>
and old <code>Foo</code> headers will be overridden if there's any.

When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So
<geshi lang="nginx">
    ngx.req.set_header("X-Foo", nil)
</geshi>
is equivalent to
<geshi lang="nginx">
    ngx.req.clear_header("X-Foo")
</geshi>
== ngx.req.clear_header ==
'''syntax:''' ''ngx.req.clear_header(header_name)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Clear the current request's request header named <code>header_name</code>. None of the current request's subrequests will be affected.

== ngx.exec ==
'''syntax:''' ''ngx.exec(uri, args?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Does an internal redirect to uri with args.
<geshi lang="nginx">
    ngx.exec('/some-location');
    ngx.exec('/some-location', 'a=3&b=5&c=6');
    ngx.exec('/some-location?a=3&b=5', 'c=6');
</geshi>
Named locations are also supported, but query strings are ignored. For example
<geshi lang="nginx">
    location /foo {
        content_by_lua '
            ngx.exec("@bar");
        ';
    }
 
    location @bar {
        ...
    }
</geshi>
Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
it's just an internal redirect and no new HTTP traffic is involved.

This method never returns.

This method MUST be called before <code>ngx.send_headers()</code> or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

This method is very much like the <code>echo_exec</code>
directive in the ngx_echo module.

== ngx.redirect ==
'''syntax:''' ''ngx.redirect(uri, status?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue an HTTP 301 or 302 redirection to <code>uri</code>.

The optional <code>status</code> parameter specifies whether
301 or 302 to be used. It's 302 (ngx.HTTP_MOVED_TEMPORARILY) by default.

Here's a small example:
<geshi lang="nginx">
    return ngx.redirect("/foo")
</geshi>
which is equivalent to
<geshi lang="nginx">
    return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
</geshi>
assuming the current server name is <code>localhost</code> and it's listening on the <code>1984</code> port.

This method MUST be called before <code>ngx.send_headers()</code> or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

This method never returns.

This method is very much like the <code>rewrite</code> directive with the <code>redirect</code> modifier in the standard
<code>ngx_rewrite</code> module, for example, this <code>nginx.conf</code> snippet
<geshi lang="nginx">
    rewrite ^ /foo redirect;  # nginx config
</geshi>
is equivalent to the following Lua code
<geshi lang="nginx">
    return ngx.redirect('/foo');  -- lua code
</geshi>
while
<geshi lang="nginx">
    rewrite ^ /foo permanent;  # nginx config
</geshi>
is equivalent to
<geshi lang="nginx">
    return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
</geshi>
== ngx.send_headers ==
'''syntax:''' ''ngx.send_headers()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly send out the response headers.

Usually you don't have to send headers yourself. ngx_lua
will automatically send out headers right before you
output contents via [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]].

Headers will also be sent automatically when [[#content_by_lua|content_by_lua]] exits normally.

== ngx.print ==
'''syntax:''' ''ngx.print(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Emit args concatenated to the HTTP client (as response body).

Lua nil value will result in outputing "nil", and Lua boolean values will emit "true" or "false".

Also, nested arrays of strings are also allowed. The elements in the arrays will be sent one by one. For example
<geshi lang="nginx">
    local table = {
        "hello, ",
        {"world: ", true, " or ", false,
            {": ", nil}}
    }
    ngx.print(table)
</geshi>
will yield the output
<geshi lang="nginx">
    hello, world: true or false: nil
</geshi>
Non-array table arguments will cause a Lua exception to be thrown.

== ngx.say ==
'''syntax:''' ''ngx.say(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.

== ngx.log ==
'''syntax:''' ''ngx.log(log_level, ...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Log args concatenated to error.log with the given logging level.

Lua nil arguments are accepted and result in literal "nil", and Lua booleans result in "true" or "false".

== ngx.flush ==
'''syntax:''' ''ngx.flush()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Force flushing the response outputs.

== ngx.exit ==
'''syntax:''' ''ngx.exit(status)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

When status >= 200 (ngx.HTTP_OK), it will interrupt the execution of the current Lua thread and returns
status code to nginx.

When status == 0 (ngx.OK), it will quits the current phase handler (or content handler if content_by_lua* directives are used).

The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
<code>ngx.HTTP_MOVED_TEMPORARILY</code>,
or other HTTP status numbers.

== ngx.eof ==
'''syntax:''' ''ngx.eof()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly specify the end of the response output stream.

== ngx.escape_uri ==
'''syntax:''' ''newstr = ngx.escape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Escape <code>str</code> as a URI component.

== ngx.unescape_uri ==
'''syntax:''' ''newstr = ngx.unescape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Unescape <code>str</code> as a escaped URI component.

== ngx.encode_base64 ==
'''syntax:''' ''newstr = ngx.encode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Encode <code>str</code> to a base64 digest.

== ngx.decode_base64 ==
'''syntax:''' ''newstr = ngx.decode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Decode <code>str</code> as a base64 digest to the raw form.

== ngx.today ==
'''syntax:''' ''str = ngx.today()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns today's date (in the format <code>yyyy-mm-dd</code>) from nginx cached time (no syscall involved unlike Lua's date library).
.

This is the local time.

== ngx.time ==
'''syntax:''' ''secs = ngx.time()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns the elapsed seconds from the epoch for the current timestamp from the nginx cached time (no syscall involved unlike Lua's date library).

== ngx.localtime ==
'''syntax:''' ''str = ngx.localtime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's date library).

This is the local time.

== ngx.utctime ==
'''syntax:''' ''str = ngx.utctime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's date library).

This is the UTC time.

== ngx.cookie_time ==
'''syntax:''' ''str = ngx.cookie_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a formated string can be used as the cookie expiration time. The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
<geshi lang="nginx">
    ngx.say(ngx.cookie_time(1290079655))
        -- yields "Thu, 18-Nov-10 11:27:35 GMT"
</geshi>
== ngx.http_time ==
'''syntax:''' ''str = ngx.http_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
<geshi lang="nginx">
    ngx.say(ngx.http_time(1290079655))
        -- yields "Thu, 18 Nov 10 11:27:35 GMT"
</geshi>
== ngx.parse_http_time ==
'''syntax:''' ''sec = ngx.parse_http_time(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Parse the http time string (as returned by [[#ngx.http_time|ngx.http_time]]) into seconds. Returns the seconds or <code>nil</code> if the input string is in bad forms.
<geshi lang="nginx">
    local time = ngx.parse_http_time("Thu, 18 Nov 10 11:27:35 GMT")
    if time == nil then
        ...
    end
</geshi>
== ngx.is_subrequest ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns true if the current request is an nginx subrequest, or false otherwise.

== ndk.set_var.DIRECTIVE ==
'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This mechanism allows calling other nginx C modules' directives that are
implemented by Nginx Devel Kit (NDK)'s set_var submodule's ndk_set_var_value.

For example, ngx_set_misc module's <code>set_escape_uri</code>, <code>set_quote_sql_str</code>, and etc.

For instance,
<geshi lang="nginx">
    local res = ndk.set_var.set_escape_uri('a/b');
    -- now res == 'a%2fb'
</geshi>
This feature requires the ngx_devel_kit module.

== HTTP 1.0 support ==

The HTTP 1.0 protocol does not support chunked outputs and always requires an
explicit <code>Content-Length</code> header when the response body is non-empty. So when
an HTTP 1.0 request is present, This module will automatically buffer all the
outputs of user calls of [[#ngx.say|ngx.say]] and [[#ngx.print|ngx.print]] and
postpone sending response headers until it sees all the outputs in the response
body, and at that time ngx_lua can calculate the total length of the body and
construct a proper <code>Content-Length</code> header for the HTTP 1.0 client.

Note that, common HTTP benchmark tools like <code>ab</code> and <code>http_load</code> always issue
HTTP 1.0 requests by default. To force <code>curl</code> to send HTTP 1.0 requests, use
the <code>-0</code> option.

= Performance =

The Lua state (aka the Lua vm instance) is shared across all the requests
handled by a single nginx worker process to miminize memory use.

On a ThinkPad T400 2.80 GHz laptop, it's easy to achieve 25k req/sec using ab
w/o keepalive and 37k+ req/sec with keepalive.

You can get better performance when building this module
with LuaJIT 2.0.

= Installation =

You're recommended to install this module as well as the Lua interpreter or LuaJIT 2.0 (with many other good stuffs) via the ngx_openresty bundle:

http://openresty.org 

The installation steps are usually as simple as ./configure && make && make install

Alternatively, you can compile this module with nginx core's source by hand:

# Install lua into your system. At least Lua 5.1 is required.
Lua can be obtained freely from its project [homepage](http://www.lua.org/).
For Ubuntu/Debian users, just install the liblua5.1-0-dev package (or something like that).

# Download the latest version of the release tarball of the ngx_devel_kit (NDK) module from
lua-nginx-module [file list](http://github.com/simpl/ngx_devel_kit/downloads).

# Download the latest version of the release tarball of this module from
lua-nginx-module [file list](http://github.com/chaoslawful/lua-nginx-module/downloads).

# Grab the nginx source code from [nginx.net](http://nginx.net/), for example,
the version 0.8.54 (see nginx compatibility), and then build the source with
this module:
<geshi lang="nginx">
        $ wget 'http://sysoev.ru/nginx/nginx-0.8.54.tar.gz'
        $ tar -xzvf nginx-0.8.54.tar.gz
        $ cd nginx-0.8.54/
 
        # tell nginx's build system where to find lua:
        export LUA_LIB=/path/to/lua/lib
        export LUA_INC=/path/to/lua/include
 
        # or tell where to find LuaJIT when you want to use JIT instead
        # export LUAJIT_LIB=/path/to/luajit/lib
        # export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
 
        # Here we assume you would install you nginx under /opt/nginx/.
        $ ./configure --prefix=/opt/nginx \
            --add-module=/path/to/ngx_devel_kit \
            --add-module=/path/to/lua-nginx-module
 
        $ make -j2
        $ make install
</geshi>
= Compatibility =

The following versions of Nginx should work with this module:

*   1.0.x (last tested: 1.0.5)
*   0.9.x (last tested: 0.9.4)
*   0.8.x >= 0.8.54 (last tested: 0.8.54)

Earlier versions of Nginx like 0.6.x and 0.5.x will '''not''' work.

If you find that any particular version of Nginx above 0.8.54 does not
work with this module, please consider reporting a bug.

= Test Suite =

To run the test suite, you also need the following dependencies:

* Nginx version > 0.8.53

* Perl modules:
** test-nginx: http://github.com/agentzh/test-nginx 

* Nginx modules:
** echo-nginx-module: http://github.com/agentzh/echo-nginx-module 
** drizzle-nginx-module: http://github.com/chaoslawful/drizzle-nginx-module 
** rds-json-nginx-module: http://github.com/agentzh/rds-json-nginx-module 
** set-misc-nginx-module: http://github.com/agentzh/set-misc-nginx-module 
** headers-more-nginx-module: http://github.com/agentzh/headers-more-nginx-module 
** memc-nginx-module: http://github.com/agentzh/memc-nginx-module 
** srcache-nginx-module: http://github.com/agentzh/srcache-nginx-module 
** ngx_auth_request: http://mdounin.ru/hg/ngx_http_auth_request_module/ 

* C libraries:
** yajl: https://github.com/lloyd/yajl 

* Lua modules:
** lua-yajl: https://github.com/brimworks/lua-yajl 
*** Note: the compiled module has to be placed in '/usr/local/lib/lua/5.1/'

* Applications:
** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
** memcached

These module's adding order is IMPORTANT! For filter modules's position in
filtering chain affects a lot. The correct configure adding order is:

# ngx_devel_kit
# set-misc-nginx-module
# ngx_http_auth_request_module
# echo-nginx-module
# memc-nginx-module
# lua-nginx-module (i.e. this module)
# headers-more-nginx-module
# srcache-nginx-module
# drizzle-nginx-module
# rds-json-nginx-module

= TODO =

* Add <code>ignore_resp_headers</code>, <code>ignore_resp_body</code>, and <code>ignore_resp</code> options to
[[#ngx.location.capture|ngx.location.capture]] and ngx.location.capture_multi` methods, to allow
micro performance tuning on the user side.
* Add directives to run lua codes when nginx stops/reloads.
* Deal with TCP 3-second delay problem under great connection harness.

= Future Plan =

* Add the <code>lua_require</code> directive to load module into main thread's globals.
* Add the "cosocket" mechamism that will emulate a common set of Lua socket
API that will give you totally transparently non-blocking capability out of
the box by means of a completely new upstream layer atop the nginx event model
and no nginx subrequest overheads.
* Add Lua code automatic time slicing support by yielding and resuming
the Lua VM actively via Lua's debug hooks.
* Make set_by_lua using the same mechanism as content_by_lua.

= Known Issues =

* Because the standard Lua 5.1 interpreter's VM is not fully resumable, the [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] methods cannot be used within the context of a Lua <code>pcall()</code> or <code>xpcall()</code>. If you're heavy on Lua exception model based on Lua's <code>error()</code> and <code>pcall()</code>/<code>xpcall()</code>, use LuaJIT 2.0 instead because LuaJIT 2.0 supports fully resumable VM.

* The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] Lua methods cannot capture
locations configured by ngx_echo module's <code>echo_location</code>, <code>echo_location_async</code>, <code>echo_subrequest</code>, or <code>echo_subrequest_async</code> directives. This won't be fixed in the future due to technical problems :)

* The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] Lua methods cannot capture locations with internal redirections for now. But this may get fixed in the future.

* '''WATCH OUT: Globals WON'T persist between requests''', because of the one-coroutine-per-request isolation design. Especially watch yourself when using <code>require()</code> to import modules, and use this form:
<geshi lang="nginx">
        local xxx = require('xxx')
</geshi>
: instead of the old deprecated form:
<geshi lang="nginx">
        require('xxx')
</geshi>
: The old form will cause module unusable in requests for the reason told previously. If you have to stick with the old form, you can always force loading module for every request by clean <code>package.loaded.<module></code>, like this:
<geshi lang="nginx">
        package.loaded.xxx = nil
        require('xxx')
</geshi>
* It's recommended to always put the following piece of code at the end of your Lua modules using [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] to prevent casual use of module-level global variables that are shared among ''all'' requests, which is usually not what you want:
<geshi lang="nginx">
    getmetatable(foo.bar).__newindex = function (table, key, val)
        error('Attempt to write to undeclared variable "' .. key .. '": '
                .. debug.traceback())
    end
</geshi>
assuming your current Lua module is named <code>foo.bar</code>. This will guarantee that you have declared your Lua functions' local Lua variables as "local" in your Lua modules, or bad race conditions while accessing these variables under load will tragically happen. See the <code>Data Sharing within an Nginx Worker</code> for the reasons of this danger.

= Data Sharing within an Nginx Worker =

'''NOTE: This mechanism behaves differently when code cache is turned off, and should be considered as a DIRTY TRICK. Backward compatibility is NOT guaranteed. Use at your own risk! We're going to design a whole new data-sharing mechanism.'''

If you want to globally share user data among all the requests handled by the same nginx worker process, you can encapsulate your shared data into a Lua module, require the module in your code, and manipulate shared data through it. It works because required Lua modules are loaded only once, and all coroutines will share the same copy of the module.

Here's a complete small example:
<geshi lang="nginx">
    -- mydata.lua
    module("mydata", package.seeall)
 
    local data = {
        dog = 3,
        cat = 4,
        pig = 5,
    }
 
    function get_age(name)
        return data[name]
    end
</geshi>
and then accessing it from your nginx.conf:
<geshi lang="nginx">
    location /lua {
        content_lua_by_lua '
            local mydata = require("mydata")
            ngx.say(mydata.get_age("dog"))
        ';
    }
</geshi>
Your <code>mydata</code> module in this example will only be loaded
and run on the first request to the location <code>/lua</code>,
and all those subsequent requests to the same nginx
worker process will use the reloaded instance of the
module as well as the same copy of the data in it,
until you send a <code>HUP</code> signal to the nginx master
process to enforce a reload.

This data sharing technique is essential for high-performance Lua apps built atop this module. It's common to cache reusable data globally.

It's worth noting that this is ''per-worker'' sharing, not ''per-server'' sharing. That is, when you have multiple nginx worker processes under an nginx master, this data sharing cannot pass process boundry. If you indeed need server-wide data sharing, you can

# Use only a single nginx worker and a single server. This is not recommended when you have a mulit-core CPU or multiple CPUs in a single machine.
# Use some true backend storage like <code>memcached</code>, <code>redis</code>, or an RDBMS like <code>mysql</code>.

= See Also =

* "Introduction to ngx_lua" ( https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction )
* ngx_devel_kit ( http://github.com/simpl/ngx_devel_kit )
* echo-nginx-module ( http://github.com/agentzh/echo-nginx-module )
* drizzle-nginx-module ( http://github.com/chaoslawful/drizzle-nginx-module )
* postgres-nginx-module ( http://github.com/FRiCKLE/ngx_postgres )
* memc-nginx-module ( http://github.com/agentzh/memc-nginx-module )

= Authors =

* chaoslawful () <chaoslawful at gmail dot com>
* Yichun "agentzh" Zhang () <agentzh at gmail dot com>

= Copyright & License =

This module is licenced under the BSD license.

Copyright (C) 2009, 2010, 2011, Taobao Inc., Alibaba Group ( http://www.taobao.com ).

Copyright (C) 2009, 2010, 2011, by Xiaozhe Wang (chaoslawful) <chaoslawful@gmail.com>.

Copyright (C) 2009, 2010, 2011, by Zhang "agentzh" Yichun () <agentzh@gmail.com>.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

