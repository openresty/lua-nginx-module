= Name =

ngx_lua - Embed the power of Lua into Nginx

''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].

= Status =

This module is under active development and is production ready.

= Version =

This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.5.0rc28] released on 16 May 2012.

= Synopsis =
<geshi lang="nginx">
    # set search paths for pure Lua external libraries (';;' is the default path):
    lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
 
    # set search paths for Lua external libraries written in C (can also use ';;'):
    lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
 
    server {
        location /inline_concat {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            set $a "hello";
            set $b "world";
            # inline Lua script
            set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
            echo $res;
        }
 
        location /rel_file_concat {
            set $a "foo";
            set $b "bar";
            # script path relative to nginx prefix
            # $ngx_prefix/conf/concat.lua contents:
            #
            #    return ngx.arg[1]..ngx.arg[2]
            #
            set_by_lua_file $res conf/concat.lua $a $b;
            echo $res;
        }
 
        location /abs_file_concat {
            set $a "fee";
            set $b "baz";
            # absolute script path not modified
            set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
            echo $res;
        }
 
        location /lua_content {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua "ngx.say('Hello,world!')";
        }
 
         location /nginx_var {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            # try access /nginx_var?a=hello,world
            content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
        }
 
        location /request_body {
             # force reading request body (default off)
             lua_need_request_body on;
             client_max_body_size 50k;
             client_body_buffer_size 50k;
 
             content_by_lua 'ngx.print(ngx.var.request_body)';
        }
 
        # transparent non-blocking I/O in Lua via subrequests
        location /lua {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
                local res = ngx.location.capture("/some_other_location")
                if res.status == 200 then
                    ngx.print(res.body)
                end';
        }
 
        # GET /recur?num=5
        location /recur {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
               local num = tonumber(ngx.var.arg_num) or 0

               if num > 50 then
                   ngx.say("num too big")
                   return
               end

               ngx.say("num is: ", num)
 
               if num > 0 then
                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
                   ngx.print("status=", res.status, " ")
                   ngx.print("body=", res.body)
               else
                   ngx.say("end")
               end
               ';
        }
 
        location /foo {
            rewrite_by_lua '
                res = ngx.location.capture("/memc",
                    { args = { cmd = 'incr', key = ngx.var.uri } }
                )
            ';
 
            proxy_pass http://blah.blah.com;
        }
 
        location /blah {
            access_by_lua '
                local res = ngx.location.capture("/auth")
 
                if res.status == ngx.HTTP_OK then
                    return
                end
 
                if res.status == ngx.HTTP_FORBIDDEN then
                    ngx.exit(res.status)
                end
 
                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            ';
 
            # proxy_pass/fastcgi_pass/postgres_pass/...
        }
 
        location /mixed {
            rewrite_by_lua_file /path/to/rewrite.lua;
            access_by_lua_file /path/to/access.lua;
            content_by_lua_file /path/to/content.lua;
        }
 
        # use nginx var in code path
        # WARN: contents in nginx var must be carefully filtered,
        # otherwise there'll be great security risk!
        location ~ ^/app/(.+) {
                content_by_lua_file /path/to/lua/app/root/$1.lua;
        }
 
        location / {
           lua_need_request_body on;
 
           client_max_body_size 100k;
           client_body_buffer_size 100k;
 
           access_by_lua '
               -- check the client IP addr is in our black list
               if ngx.var.remote_addr == "132.5.72.3" then
                   ngx.exit(ngx.HTTP_FORBIDDEN)
               end
 
               -- check if the request body contains bad words
               if ngx.var.request_body and
                        string.match(ngx.var.request_body, "fsck")
               then
                   return ngx.redirect("/terms_of_use.html")
               end
 
               -- tests passed
           ';
 
           # proxy_pass/fastcgi_pass/etc settings
        }
    }
</geshi>

= Description =

This module embeds Lua, via the standard Lua interpreter or LuaJIT, into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.

Unlike [http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] and [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet], Lua code executed using this module can be ''100% non-blocking'' on network traffic as long as the [[#Nginx API for Lua|Nginx API for Lua]] provided by this module is used to handle
requests to upstream services such as mysql, postgresql, memcached, redis, or upstream http web services. (See [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], [[#ngx.socket.tcp|ngx.socket.tcp]], [[HttpDrizzleModule]], [http://github.com/FRiCKLE/ngx_postgres/ ngx_postgres], [[HttpMemcModule]], [[HttpRedis2Module]] and [[HttpProxyModule]] modules for details).

The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines. 
Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint even when under heavy loads.

= Directives =

== lua_code_cache ==
'''syntax:''' ''lua_code_cache on | off''

'''default:''' ''lua_code_cache on''

'''context:''' ''main, server, location, location if''

Enables or disables the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.

The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
and [[#rewrite_by_lua_file|rewrite_by_lua_file]] will not be cached
and the Lua <code>package.loaded</code> table will be cleared
at the entry point of every request (such that Lua modules
will not be cached either). With this in place, developers can adopt an edit-and-refresh approach.

Please note however, that Lua code inlined into nginx.conf
such as those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
cached because only the Nginx config file parser can correctly parse the <code>nginx.conf</code>
file and the only ways to to reload the config file
are to send a <code>HUP</code> signal or to restart Nginx.

The ngx_lua module does not currently support the <code>stat</code> mode available with the 
Apache <code>mod_lua</code> module but this is planned for implementation in the future.

Disabling the Lua code cache is strongly
discouraged for production use and should only be used during 
development as it has a significant negative impact on overall performance.
In addition, race conditions when reloading Lua modules are common for concurrent requests
when the code cache is disabled.

== lua_regex_cache_max_entries ==
'''syntax:''' ''lua_regex_cache_max_entries <num>''

'''default:''' ''lua_regex_cache_max_entries 1024''

'''context:''' ''http''

Specifies the maximum number of entries allowed in the worker process level compiled regex cache.

The regular expressions used in [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.

The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:

<geshi lang="text">
    2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...
</geshi>

Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for [[#ngx.re.sub|ngx.re.sub]] and [[#ngx.re.gsub|ngx.re.gsub]]) that are generated ''on the fly'' and give rise to infinite variations to avoid hitting the specified limit.

== lua_package_path ==

'''syntax:''' ''lua_package_path <lua-style-path-str>''

'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''

'''context:''' ''main''

Sets the Lua module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The path string is in standard Lua path form, and <code>;;</code>
can be used to stand for the original search paths.

Since the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

== lua_package_cpath ==

'''syntax:''' ''lua_package_cpath <lua-style-cpath-str>''

'''default:''' ''The content of LUA_CPATH environment variable or Lua's compiled-in defaults.''

'''context:''' ''main''

Sets the Lua C-module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The cpath string is in standard Lua cpath form, and <code>;;</code>
can be used to stand for the original cpath.

Since the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

== set_by_lua ==

'''syntax:''' ''set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

'''phase:''' ''rewrite''

Executes code specified in <code><lua-script-str></code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>. 
The code in <code><lua-script-str></code> can make [[#Nginx API for Lua|API calls]] and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).

This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.

Note that I/O operations such as [[#ngx.say|ngx.say]], [[#ngx.exec|ngx.exec]], [[HttpEchoModule#echo|echo]] and similar are not permitted within the context of this directive.

In addition, note that this directive can only write out a value to a single Nginx variable at
a time. However, a workaround is possible using the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface.

<geshi lang="nginx">
    location /foo {
        set $diff ''; # we have to predefine the $diff variable here
 
        set_by_lua $sum '
            local a = 32
            local b = 56
 
            ngx.var.diff = a - b;  -- write to $diff directly
            return a + b;          -- return the $sum value normally
        ';
 
        echo "sum = $sum, diff = $diff";
    }
</geshi>

This directive can be freely mixed with all directives of the [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]] modules. All of these directives will run in the same order as they appear in the config file.

<geshi lang="nginx">
    set $foo 32;
    set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
    set $baz "bar: $bar";  # $baz == "bar: 33"
</geshi>

Since the <code>0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code><lua-script-str></code> argument of this directive, and you can use the dollar sign character (<code>$</code>) directly.

This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

== set_by_lua_file ==
'''syntax:''' ''set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

'''phase:''' ''rewrite''

Equivalent to [[#set_by_lua|set_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code to be executed.

Nginx variable interpolation is supported in the <code><path-to-lua-script-file></code> argument string of this directive. But special care must be taken for injection attacks.

When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absoluate path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by 
switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.

This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

== content_by_lua ==

'''syntax:''' ''content_by_lua <lua-script-str>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Acts as a "content handler" and executes Lua code string specified in <code><lua-script-str></code> for every request. 
The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

Do not use this directive and other content handler directives in the same location. For example, this directive and the [[HttpProxyModule#proxy_pass|proxy_pass]] directive should not be used in the same location.

== content_by_lua_file ==

'''syntax:''' ''content_by_lua_file <path-to-lua-script-file>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Equivalent to [[#content_by_lua|content_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code to be executed.

Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absoluate path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by 
switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.

== rewrite_by_lua ==

'''syntax:''' ''rewrite_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Acts as a rewrite phase handler and executes Lua code string specified in <code><lua-script-str></code> for every request.
The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

Note that this handler always runs ''after'' the standard [[HttpRewriteModule]]. So the following will work as expected:

<geshi lang="nginx">
   location /foo {
       set $a 12; # create and initialize $a
       set $b ""; # create and initialize $b
       rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
       echo "res = $b";
   }
</geshi>

because <code>set $a 12</code> and <code>set $b ""</code> run ''before'' [[#rewrite_by_lua|rewrite_by_lua]].

On the other hand, the following will not work as expected:

<geshi lang="nginx">
    ?  location /foo {
    ?      set $a 12; # create and initialize $a
    ?      set $b ''; # create and initialize $b
    ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
    ?      if ($b = '13') {
    ?         rewrite ^ /bar redirect;
    ?         break;
    ?      }
    ?
    ?      echo "res = $b";
    ?  }
</geshi>

because <code>if</code> runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it is placed after [[#rewrite_by_lua|rewrite_by_lua]] in the config.

The right way of doing this is as follows:

<geshi lang="nginx">
    location /foo {
        set $a 12; # create and initialize $a
        set $b ''; # create and initialize $b
        rewrite_by_lua '
            ngx.var.b = tonumber(ngx.var.a) + 1
            if tonumber(ngx.var.b) == 13 then
                return ngx.redirect("/bar");
            end
        ';
 
        echo "res = $b";
    }
</geshi>

Note that the [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] module can be approximated by using [[#rewrite_by_lua|rewrite_by_lua]]. For example,

<geshi lang="nginx">
    location / {
        eval $res {
            proxy_pass http://foo.com/check-spam;
        }
 
        if ($res = 'spam') {
            rewrite ^ /terms-of-use.html redirect;
        }
 
        fastcgi_pass ...;
    }
</geshi>

can be implemented in <code>ngx_lua</code> as:

<geshi lang="nginx">
    location = /check-spam {
        internal;
        proxy_pass http://foo.com/check-spam;
    }
 
    location / {
        rewrite_by_lua '
            local res = ngx.location.capture("/check-spam")
            if res.body == "spam" then
                ngx.redirect("/terms-of-use.html")
            end
        ';
 
        fastcgi_pass ...;
    }
</geshi>

Just as any other rewrite phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.

Note that when calling <code>ngx.exit(ngx.OK)</code> within a [[#rewrite_by_lua|rewrite_by_lua]] handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [[#rewrite_by_lua|rewrite_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.

If the [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive is used to change the URI and initiate location re-lookups (internal redirections), then any [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code sequences within the current location will not be executed. For example,

<geshi lang="nginx">
    location /foo {
        rewrite ^ /bar;
        rewrite_by_lua 'ngx.exit(503)';
    }
    location /bar {
        ...
    }
</geshi>

Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the rewrite_by_lua code will be executed.

== rewrite_by_lua_file ==

'''syntax:''' ''rewrite_by_lua_file <path-to-lua-script-file>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Equivalent to [[#rewrite_by_lua|rewrite_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code to be executed.

Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absoluate path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.

== access_by_lua ==

'''syntax:''' ''access_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Acts as an access phase handler and executes Lua code string specified in <code><lua-script-str></code> for every request.
The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).

Note that this handler always runs ''after'' the standard [[HttpAccessModule]]. So the following will work as expected:

<geshi lang="nginx">
    location / {
        deny    192.168.1.1;
        allow   192.168.1.0/24;
        allow   10.1.1.0/16;
        deny    all;
 
        access_by_lua '
            local res = ngx.location.capture("/mysql", { ... })
            ...
        ';
 
        # proxy_pass/fastcgi_pass/...
    }
</geshi>

That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [[#access_by_lua|access_by_lua]].

Note that the [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] module can be approximated by using [[#access_by_lua|access_by_lua]]:

<geshi lang="nginx">
    location / {
        auth_request /auth;
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>

can be implemented in <code>ngx_lua</code> as:

<geshi lang="nginx">
    location / {
        access_by_lua '
            local res = ngx.location.capture("/auth")
 
            if res.status == ngx.HTTP_OK then
                return
            end
 
            if res.status == ngx.HTTP_FORBIDDEN then
                ngx.exit(res.status)
            end
 
            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        ';
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>

As with other access phase handlers, [[#access_by_lua|access_by_lua]] will ''not'' run in subrequests.

Note that when calling <code>ngx.exit(ngx.OK)</code> within a [[#access_by_lua|access_by_lua]] handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a [[#access_by_lua|access_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.

== access_by_lua_file ==

'''syntax:''' ''access_by_lua_file <path-to-lua-script-file>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Equivalent to [[#access_by_lua|access_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code to be executed.

Nginx variables can be used in the <code><path-to-lua-script-file></code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.

When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absoluate path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.
The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.

== header_filter_by_lua ==

'''syntax:''' ''header_filter_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''output-header-filter''

Uses Lua code specified in <code><lua-script-str></code> to define an output header filter. Note that the following API functions are currently disabled within this context:

* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API functions (e.g., [[#ngx.exit|ngx.exit]]) 
* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])

Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:

<geshi lang="nginx">
    location / {
        proxy_pass http://mybackend;
        header_filter_by_lua 'ngx.header.Foo = "blah"';
    }
</geshi>

This directive was first introduced in the <code>v0.2.1rc20</code> release.

== header_filter_by_lua_file ==

'''syntax:''' ''header_filter_by_lua_file <path-to-lua-script-file>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''output-header-filter''

Equivalent to [[#header_filter_by_lua|header_filter_by_lua]], except that the file specified by <code><path-to-lua-script-file></code> contains the Lua code to be executed.

When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absoluate path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.

This directive was first introduced in the <code>v0.2.1rc20</code> release.

== lua_need_request_body ==

'''syntax:''' ''lua_need_request_body <on|off>''

'''default:''' ''off''

'''context:''' ''main | server | location''

'''phase:''' ''depends on usage''

Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the [[#ngx.req.read_body|ngx.req.read_body]] function should be called within the Lua code.

To read the request body data within the [[HttpCoreModule#$request_body|$request_body]] variable, 
[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] must have the same value as [[HttpCoreModule#client_max_body_size|client_max_body_size]]. Because when the content length exceeds [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] but less than [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx will automatically buffer the data into a temporary file on the disk, which will lead to empty value in the [[HttpCoreModule#$request_body|$request_body]] variable.

If the current location includes [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives,
then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
<code>rewrite</code> phase). Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
the request body will not be read until the content handler's Lua code is
about to run (i.e., the request body will be read during the content phase).

It is recommended however, to use the [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]] functions for finer control over the request body reading process instead.

This also applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].

== lua_shared_dict ==

'''syntax:''' ''lua_shared_dict <name> <size>''

'''default:''' ''no''

'''context:''' ''http''

'''phase:''' ''depends on usage''

Declares a shared memory zone, <code><name></code>, to serve as storage for the shm-based Lua dictionary <code>ngx.shared.<name></code>.

The <code><size></code> argument accepts size units such as <code>k</code> and <code>m</code>:

<geshi lang="nginx">
    http {
        lua_shared_dict dogs 10m;
        ...
    }
</geshi>

See [[#ngx.shared.DICT|ngx.shared.DICT]] for details.

This directive was first introduced in the <code>v0.3.1rc22</code> release.

== lua_socket_connect_timeout ==

'''syntax:''' ''lua_socket_connect_timeout <time>''

'''default:''' ''lua_socket_connect_timeout 60s''

'''context:''' ''http, server, location''

This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:connect|connect]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.

The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_socket_send_timeout ==

'''syntax:''' ''lua_socket_send_timeout <time>''

'''default:''' ''lua_socket_send_timeout 60s''

'''context:''' ''http, server, location''

Controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:send|send]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.

The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_socket_send_lowat ==

'''syntax:''' ''lua_socket_send_lowat <size>''

'''default:''' ''lua_socket_send_lowat 0''

'''context:''' ''http, server, location''

Controls the <code>lowat</code> (low water) value for the cosocket send buffer.

== lua_socket_read_timeout ==

'''syntax:''' ''lua_socket_read_timeout <time>''

'''default:''' ''lua_socket_read_timeout 60s''

'''context:''' ''http, server, location''

'''phase:''' ''depends on usage''

This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:receive|receive]] method and iterator functions returned by the [[#tcpsock:receiveuntil|receiveuntil]] method. This setting can be overridden by the [[#tcpsock:settimeout|settimeout]] method.

The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., "second". The default setting is <code>60s</code>.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_socket_buffer_size ==

'''syntax:''' ''lua_socket_buffer_size <size>''

'''default:''' ''lua_socket_buffer_size 4k/8k''

'''context:''' ''http, server, location''

Specifies the buffer size used by cosocket reading operations.

This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_socket_pool_size ==

'''syntax:''' ''lua_socket_pool_size <size>''

'''default:''' ''lua_socket_pool_size 30''

'''context:''' ''http, server, location''

Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).

Default to 30 connections for every pool.

When the connection pool is exceeding the size limit, the least recently used (idle) connection already in the pool will be closed automatically to make room for the current connection. 

Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so so size limit specified here also applies to every single nginx worker process.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_socket_keepalive_timeout ==

'''syntax:''' ''lua_socket_keepalive_timeout <time>''

'''default:''' ''lua_socket_keepalive_timeout 60s''

'''context:''' ''http, server, location''

This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed automatically and removed from the pool. This setting can be overridden by cosocket objects' [[#tcpsock:setkeepalive|setkeepalive]] method.

The <code><time></code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, ie, "second". The default setting is <code>60s</code>.

This directive was first introduced in the <code>v0.5.0rc1</code> release.

== lua_http10_buffering ==

'''syntax:''' ''lua_http10_buffering on|off''

'''default:''' ''lua_http10_buffering on''

'''context:''' ''http, server, location, location-if''

Enables or disables the automatic response caching for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper <code>Content-Length</code> response header.

If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicity via [[#ngx.send_headers|ngx.send_headers]] or implicitly via the first [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] call).

If you want to output huge response data in a streaming fashion (via the [[#ngx.flush|ngx.flush]] call, for example), then you MUST turn off this directive to prevent memory footprint boost.

This directive is turned <code>on</code> by default.

This directive was first introduced in the <code>v0.5.0rc19</code> release.

== rewrite_by_lua_no_postpone ==

'''syntax:''' ''rewrite_by_lua_no_postpone on|off''

'''default:''' ''rewrite_by_lua_no_postpone off''

'''context:''' ''http, server, location, location-if''

Controls whether or not to disable postponing [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.

This directive was first introduced in the <code>v0.5.0rc29</code> release.

= Nginx API for Lua =
== Introduction ==
The various <code>*_by_lua</code> and <code>*_by_lua_file</code> configuration directives serve as gateways to the Lua API within the <code>nginx.conf</code> file. The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.

The API is exposed to Lua in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope within <code>ngx_lua</code> and are always available within <code>ngx_lua</code> directives.

The packages can be introduced into external Lua modules by using the [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] option:

<geshi lang="lua">
    module("my_module", package.seeall)

    function say(a) ngx.say(a) end
</geshi>

Alternatively, they can be imported to external Lua modules by using file scoped local Lua variables:

<geshi lang="lua">
    local ngx = ngx
    module("my_module")

    function say(a) ngx.say(a) end
</geshi>

It is also possible to directly require the packages in external Lua modules:

<geshi lang="lua">
    local ngx = require "ngx"
    local ndk = require "ndk"
</geshi>

The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.

Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise. Disk operations with relatively small amount of data can be done using the standard Lua <code>io</code> library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly. Delegating all network and disk I/O operations to Nginx's subrequests (via the [[#ngx.location.catpure|ngx.location.capture]] method and similar) is strongly recommended for maximum performance.

== ngx.arg ==
'''syntax:''' ''val = ngx.arg[index]''

'''context:''' ''set_by_lua*''

Index the input arguments to the [[#set_by_lua|set_by_lua]] and [[#set_by_lua_file|set_by_lua_file]] directives:

<geshi lang="lua">
    value = ngx.arg[n]
</geshi>

Here is an example

<geshi lang="nginx">
    location /foo {
        set $a 32;
        set $b 56;
 
        set_by_lua $res
            'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
            $a $b;
 
        echo $sum;
    }
</geshi>

that writes out <code>88</code>, the sum of <code>32</code> and <code>56</code>.

== ngx.var.VARIABLE ==
'''syntax:''' ''ngx.var.VAR_NAME''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Read and write Nginx variable values.

<geshi lang="nginx">
    value = ngx.var.some_nginx_variable_name
    ngx.var.some_nginx_variable_name = value
</geshi>

Note that only already defined nginx variables can be written to.
For example:

<geshi lang="nginx">
    location /foo {
        set $my_var ''; # this line is required to create $my_var at config time
        content_by_lua '
            ngx.var.my_var = 123;
            ...
        ';
    }
</geshi>

That is, nginx variables cannot be created on-the-fly.

Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value,
some are not, like <code>$arg_PARAMETER</code>.

Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this
interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.

Setting <code>ngx.var.Foo</code> to a <code>nil</code> value will unset the <code>$Foo</code> Nginx variable. 

<geshi lang="lua">
    ngx.var.args = nil
</geshi>

== Core constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="lua">
  ngx.OK (0)
  ngx.ERROR (-1)
  ngx.AGAIN (-2)
  ngx.DONE (-4)
  ngx.DECLINED (-5)
</geshi>

Note that only three of these constants are utilized by the [[#Nginx API for Lua|Nginx API for Lua]] (i.e., [[#ngx.exit|ngx.exit]] accepts <code>NGX_OK</code>, <code>NGX_ERROR</code>, and <code>NGX_DECLINED</code> as input).

<geshi lang="lua">
  ngx.null
</geshi>

The <code>ngx.null</code> constant is a <code>NULL</code> light userdata which is usually used to represent nil values in Lua tables and etc. It is identical with the [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] library's <code>cjson.null</code> constant. This constant was first introduced in the <code>v0.5.0rc5</code> release.

The <code>ngx.DECLINED</code> constant was first introduced in the <code>v0.5.0rc19</code> release.

== HTTP method constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="text">
  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
  ngx.HTTP_OPTIONS   (first introduced in the v0.5.0rc24 release)
</geshi>

These constants are usually used in [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] method calls.

== HTTP status constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="nginx">
  value = ngx.HTTP_OK (200)
  value = ngx.HTTP_CREATED (201)
  value = ngx.HTTP_SPECIAL_RESPONSE (300)
  value = ngx.HTTP_MOVED_PERMANENTLY (301)
  value = ngx.HTTP_MOVED_TEMPORARILY (302)
  value = ngx.HTTP_SEE_OTHER (303)
  value = ngx.HTTP_NOT_MODIFIED (304)
  value = ngx.HTTP_BAD_REQUEST (400)
  value = ngx.HTTP_UNAUTHORIZED (401)
  value = ngx.HTTP_FORBIDDEN (403)
  value = ngx.HTTP_NOT_FOUND (404)
  value = ngx.HTTP_NOT_ALLOWED (405)
  value = ngx.HTTP_GONE (410)
  value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
  value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)
  value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
  value = ngx.HTTP_GATEWAY_TIMEOUT (504) (first added in the v0.3.1rc38 release)
</geshi>

== Nginx log level constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="lua">
  ngx.STDERR
  ngx.EMERG
  ngx.ALERT
  ngx.CRIT
  ngx.ERR
  ngx.WARN
  ngx.NOTICE
  ngx.INFO
  ngx.DEBUG
</geshi>

These constants are usually used by the [[#ngx.log|ngx.log]] method.

== print ==
'''syntax:''' ''print(...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Writes argument values into the nginx <code>error.log</code> file with the <code>ngx.NOTICE</code> log level.

It is equivalent to

<geshi lang="lua">
    ngx.log(ngx.NOTICE, ...)
</geshi>

Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> strings while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> strings. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.

There is a hard-coded length limitation on the error messages in the Nginx core. It is <code>2048</code> bytes at most, including the trailing newlines and the leading timestamps. You can manually modify this limit by modifying the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree. If the message size exceeds this limit, the Nginx core will truncate the message text automatically.

== ngx.ctx ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables). 

Consider the following example,

<geshi lang="nginx">
    location /test {
        rewrite_by_lua '
            ngx.say("foo = ", ngx.ctx.foo)
            ngx.ctx.foo = 76
        ';
        access_by_lua '
            ngx.ctx.foo = ngx.ctx.foo + 3
        ';
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
</geshi>

Then <code>GET /test</code> will yield the output

<geshi lang="bash">
    foo = nil
    79
</geshi>

That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.

Every request, including subrequests, has its own copy of the table. For example:

<geshi lang="nginx">
    location /sub {
        content_by_lua '
            ngx.say("sub pre: ", ngx.ctx.blah)
            ngx.ctx.blah = 32
            ngx.say("sub post: ", ngx.ctx.blah)
        ';
    }
 
    location /main {
        content_by_lua '
            ngx.ctx.blah = 73
            ngx.say("main pre: ", ngx.ctx.blah)
            local res = ngx.location.capture("/sub")
            ngx.print(res.body)
            ngx.say("main post: ", ngx.ctx.blah)
        ';
    }
</geshi>

Then <code>GET /main</code> will give the output

<geshi lang="bash">
    main pre: 73
    sub pre: nil
    sub post: 32
    main post: 73
</geshi>

Here, modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in the parent request. This is because they have two separate versions of <code>ngx.ctx.blah</code>.

Internal redirection will destroy the original request <code>ngx.ctx</code> data (if any) and the new request will have an empty <code>ngx.ctx</code> table. For instance,

<geshi lang="nginx">
    location /new {
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
 
    location /orig {
        content_by_lua '
            ngx.ctx.foo = "hello"
            ngx.exec("/new")
        ';
    }
</geshi>

Then <code>GET /orig</code> will give

<geshi lang="bash">
    nil
</geshi>

rather than the original <code>"hello"</code> value.

Arbitrary data values, including Lua closures and nested tables, can be inserted into this "magic" table. It also allows the registration of custom meta methods.

Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,

<geshi lang="lua">
    ngx.ctx = { foo = 32, bar = 54 }
</geshi>

== ngx.location.capture ==
'''syntax:''' ''res = ngx.location.capture(uri, options?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue a synchronous but still non-blocking ''Nginx Subrequest'' using <code>uri</code>.

Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or ''any'' other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>,
<code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even <code>ngx_lua</code> itself and etc etc etc.

Also note that subrequests just mimic the HTTP interface but there is ''no'' extra HTTP/TCP traffic ''nor'' IPC involved. Everything works internally, efficiently, on the C level.

Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).

Here is a basic example:

<geshi lang="lua">
    res = ngx.location.capture(uri)
</geshi>

Returns a Lua table with three slots (<code>res.status</code>, <code>res.header</code>, and <code>res.body</code>).

<code>res.header</code> holds all the response headers of the
subrequest and it is a normal Lua table. For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear. For instance, if the subrequest response headers contain the following
lines:

<geshi lang="bash">
    Set-Cookie: a=3
    Set-Cookie: foo=bar
    Set-Cookie: baz=blah
</geshi>

Then <code>res.header["Set-Cookie"]</code> will be evaluted to the table value
<code>{"a=3", "foo=bar", "baz=blah"}</code>.

URI query strings can be concatenated to URI itself, for instance,

<geshi lang="lua">
    res = ngx.location.capture('/foo/bar?a=3&b=4')
</geshi>

Named locations like <code>@foo</code> are not allowed due to a limitation in
the nginx core. Use normal locations combined with the <code>internal</code> directive to
prepare internal-only locations.

An optional option table can be fed as the second
argument, which supports the options:

* <code>method</code>
: specify the subrequest's request method, which only accepts constants like <code>ngx.HTTP_POST</code>.
* <code>body</code>
: specify the subrequest's request body (string value only).
* <code>args</code>
: specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
* <code>ctx</code>
: specify a Lua table to be the [[#ngx.ctx|ngx.ctx]] table for the subrequest. It can be the current request's [[#ngx.ctx|ngx.ctx]] table, which effectively makes the parent and its subrequest to share exactly the same context table. This option was first introduced in the <code>v0.3.1rc25</code> release.
* <code>vars</code>
: take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value. This option was first introduced in the <code>v0.3.1rc31</code> release.
* <code>copy_all_vars</code>
: specify whether to copy over all the Nginx variable values of the current request to the subrequest in question. modifications of the nginx variables in the subrequest will not affect the current (parent) request. This option was first introduced in the <code>v0.3.1rc31</code> release.
* <code>share_all_vars</code>
: specify whether to share all the Nginx variables of the subrequest with the current (parent) request. modifications of the Nginx variables in the subrequest will affect the current (parent) request.

Issuing a POST subrequest, for example, can be done as follows

<geshi lang="lua">
    res = ngx.location.capture(
        '/foo/bar',
        { method = ngx.HTTP_POST, body = 'hello, world' }
    )
</geshi>

See HTTP method constants methods other than POST.
The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.

The <code>args</code> option can specify extra URI arguments, for instance,

<geshi lang="lua">
    ngx.location.capture('/foo?a=1',
        { args = { b = 3, c = ':' } }
    )
</geshi>

is equivalent to

<geshi lang="lua">
    ngx.location.capture('/foo?a=1&b=3&c=%3a')
</geshi>

that is, this method will automatically escape argument keys and values according to URI rules and
concatenating them together into a complete query string. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.

The <code>args</code> option can also take plain query strings:

<geshi lang="lua">
    ngx.location.capture('/foo?a=1',
        { args = 'b=3&c=%3a' } }
    )
</geshi>

This is functionally identical to the previous examples.

The <code>share_all_vars</code> option controls whether to share nginx variables among the current request and its subrequests. 
If this option is set to <code>true</code>, then the current request and associated subrequests will share the same Nginx variable scope. Hence, changes to Nginx variables made by a subrequest will affect the current request.

Care should be taken in using this option as variable scope sharing can have unexpected side effects. The <code>args</code>, <code>vars</code>, or <code>copy_all_vars</code> options are generally preferable instead.

This option is set to <code>false</code> by default

<geshi lang="nginx">
    location /other {
        set $dog "$dog world";                  
        echo "$uri dog: $dog";                    
    }                                     
    
    location /lua {
        set $dog 'hello';
        content_by_lua '
            res = ngx.location.capture("/other",
                { share_all_vars = true });
                
            ngx.print(res.body)
            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
        ';  
    }           
</geshi>

Accessing location <code>/lua</code> gives

<geshi lang="text">
    /other dog: hello world
    /lua: hello world
</geshi>

The <code>copy_all_vars</code> option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued. Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.

<geshi lang="nginx">
    location /other {
        set $dog "$dog world";
        echo "$uri dog: $dog";
    }

    location /lua {
        set $dog 'hello';
        content_by_lua '
            res = ngx.location.capture("/other",
                { copy_all_vars = true });

            ngx.print(res.body)
            ngx.say(ngx.var.uri, ": ", ngx.var.dog)
        ';
    }
</geshi>

Request <code>GET /lua</code> will give the output

<geshi lang="text">
    /other dog: hello world
    /lua: hello
</geshi>

Note that if both <code>share_all_vars</code> and <code>copy_all_vars</code> are set to true, then <code>share_all_vars</code> takes precedence.

In addition to the two settings above, it is possible to specify
values for variables in the subrequest using the <code>vars</code> option. These
variables are set after the sharing or copying of variables has been
evaluated, and provides a more efficient method of passing specific
values to a subrequest over encoding them as URL arguments and 
unescaping them in the Nginx config file.

<geshi lang="nginx">
    location /other {
        content_by_lua '
            ngx.say("dog = ", ngx.var.dog)
            ngx.say("cat = ", ngx.var.cat)
        ';
    }

    location /lua {
        set $dog '';
        set $cat '';
        content_by_lua '
            res = ngx.location.capture("/other",
                { vars = { dog = "hello", cat = 32 }});

            ngx.print(res.body)
        ';
    }
</geshi>

Accessing <code>/lua</code> will yield the output

<geshi lang="text">
    dog = hello
    cat = 32
</geshi>

The <code>ctx</code> option can be used to specify a custom Lua table to serve as the [[#ngx.ctx|ngx.ctx]] table for the subrequest.

<geshi lang="nginx">
    location /sub {
        content_by_lua '                          
            ngx.ctx.foo = "bar";                  
        ';
    }   
    location /lua {
        content_by_lua '
            local ctx = {}                        
            res = ngx.location.capture("/sub", { ctx = ctx })
            
            ngx.say(ctx.foo);
            ngx.say(ngx.ctx.foo);                 
        ';                                        
    }
</geshi>

Then request <code>GET /lua</code> gives

<geshi lang="text">
    bar                                               
    nil
</geshi>

It is also possible to use this <code>ctx</code> option to share the same [[#ngx.ctx|ngx.ctx]] table between the current (parent) request and the subrequest:

<geshi lang="nginx">
    location /sub {
        content_by_lua '
            ngx.ctx.foo = "bar";
        ';
    }
    location /lua {
        content_by_lua '
            res = ngx.location.capture("/sub", { ctx = ngx.ctx })
            ngx.say(ngx.ctx.foo);
        ';
    }
</geshi>

Request <code>GET /lua</code> yields the output

<geshi lang="text">
    bar
</geshi>

Note that subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
request headers of the current request by default and that this may have unexpected side effects on the
subrequest responses. For example, when using the standard <code>ngx_proxy</code> module to serve
subrequests, an "Accept-Encoding: gzip" header in the main request may result
in gzipped responses that cannot be handled properly in Lua code. Original request headers should be ignored by setting 
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] to <code>off</code> in subrequest locations.

There is a hard-coded upper limit on the number of concurrent subrequests every main request. In older versions of Nginx, the limit is <code>50</code>, which is then increased to <code>200</code> in recent Nginx <code>1.1.x</code> releases. You can manually edit this limit by modifying the definition of the <code>NGX_HTTP_MAX_SUBREQUESTS</code> macro in the <code>nginx/src/http/ngx_http_request.h</code> file in the Nginx source tree. When you are exceeding this limit, you will get the following error message in your <code>error.log</code> file:

<geshi lang="text">
    [error] 13983#0: *1 subrequests cycle while processing "/uri"
</geshi>

Please also refer to restrictions on [[#Locations_With_HttpEchoModule_Directives|capturing locations that include Echo Module directives]].

== ngx.location.capture_multi ==
'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.

This function issues several parallel subrequests specified by the input table and returns their results in the same order. For example,

<geshi lang="lua">
    res1, res2, res3 = ngx.location.capture_multi{
        { "/foo", { args = "a=3&b=4" } },
        { "/bar" },
        { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
    }
 
    if res1.status == ngx.HTTP_OK then
        ...
    end
 
    if res2.body == "BLAH" then
        ...
    end
</geshi>

This function will not return until all the subrequests terminate.
The total latency is the longest latency of the individual subrequests rather than the sum.

Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:

<geshi lang="lua">
    -- construct the requests table
    local reqs = {}
    table.insert(reqs, { "/mysql" })
    table.insert(reqs, { "/postgres" })
    table.insert(reqs, { "/redis" })
    table.insert(reqs, { "/memcached" })
 
    -- issue all the requests at once and wait until they all return
    local resps = { ngx.location.capture_multi(reqs) }
 
    -- loop over the responses table
    for i, resp in ipairs(resps) do
        -- process the response table "resp"
    end
</geshi>

The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
of this function. Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this

<geshi lang="lua">
    ngx.location.capture =
        function (uri, args)
            return ngx.location.capture_multi({ {uri, args} })
        end
</geshi>

Please also refer to restrictions on [[#Locations_With_HttpEchoModule_Directives|capturing locations that include Echo Module directives]].

== ngx.status ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Read and write the current request's response status. This should be called
before sending out the response headers.

<geshi lang="lua">
    ngx.status = ngx.HTTP_CREATED
    status = ngx.status
</geshi>

== ngx.header.HEADER ==
'''syntax:''' ''ngx.header.HEADER = VALUE''

'''syntax:''' ''value = ngx.header.HEADER''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Set, add to, or clear the current request <code>HEADER</code> response header. Underscores (<code>_</code>) in the header names will be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively.

<geshi lang="lua">
    -- equivalent to ngx.header["Content-Type"] = 'text/plain'
    ngx.header.content_type = 'text/plain';
 
    ngx.header["X-My-Header"] = 'blah blah';
</geshi>

Multi-value headers can be set this way:

<geshi lang="lua">
    ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
</geshi>

will yield

<geshi lang="bash">
    Set-Cookie: a=32; path=/
    Set-Cookie: b=4; path=/
</geshi>

in the response headers. 

Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as <code>Content-Type</code> that only accept a single value).

<geshi lang="lua">
    ngx.header.content_type = {'a', 'b'}
</geshi>

is equivalent to

<geshi lang="lua">
    ngx.header.content_type = 'b'
</geshi>

Setting a slot to <code>nil</code> effectively removes it from the response headers:

<geshi lang="lua">
    ngx.header["X-My-Header"] = nil;
</geshi>

The same applies to assigning an empty table:

<geshi lang="lua">
    ngx.header["X-My-Header"] = {};
</geshi>

Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [[#ngx.send_headers|ngx.send_headers]] or implicitly with [[#ngx.print|ngx.print]] and similar) will throw out a Lua exception.

Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>. 

Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.

This is particularly useful in the context of [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]], for example,

<geshi lang="nginx">
    location /test {
        set $footer '';

        proxy_pass http://some-backend;

        header_filter_by_lua '
            if ngx.header["X-My-Header"] == "blah" then
                ngx.var.footer = "some value"
            end
        ';

        echo_after_body $footer;
    }
</geshi>

For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers

<geshi lang="text">
    Foo: bar
    Foo: baz
</geshi>

will result in

<geshi lang="lua">
    {"bar", "baz"}
</geshi>

to be returned when reading <code>ngx.header.Foo</code>.

Note that <code>ngx.header</code> is not a normal Lua table and as such, it is not possible to iterate through it using the Lua <code>ipairs</code> function.

For reading ''request'' headers, use the [[#ngx.req.get_headers|ngx.req.get_headers]] function instead.

== ngx.req.set_uri ==
'''syntax:''' ''ngx.req.set_uri(uri, jump?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Rewrite the current request's (parsed) URI by the <code>uri</code> argument. The <code>uri</code> argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.

The optional boolean <code>jump</code> argument can trigger location rematch (or location jump) as [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive, that is, when <code>jump</code> is <code>true</code> (default to <code>false</code>), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later <code>post-rewrite</code> phase and jumping to the new location.

Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior. This function will return but with no returned values when the <code>jump</code> argument is <code>false</code> or absent altogether.

For example, the following nginx config snippet

<geshi lang="nginx">
    rewrite ^ /foo last;
</geshi>

can be coded in Lua like this:

<geshi lang="lua">
    ngx.req.set_uri("/foo", true)
</geshi>

Similarly, Nginx config

<geshi lang="nginx">
    rewrite ^ /foo break;
</geshi>

can be coded in Lua as

<geshi lang="lua">
    ngx.req.set_uri("/foo", false)
</geshi>

or equivalently,

<geshi lang="lua">
    ngx.req.set_uri("/foo")
</geshi>

The <code>jump</code> can only be set to <code>true</code> in [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]]. Use of jump in other contexts is prohibited and will throw out a Lua exception.

A more sophisticated example involving regex substitutions is as follows

<geshi lang="nginx">
    location /test {
        rewrite_by_lua '
            local uri = ngx.re.sub(ngx.var.uri, "^/test/(.*)", "$1", "o")
            ngx.req.set_uri(uri)
        ';
        proxy_pass http://my_backend;
    }
</geshi>

which is functionally equivalent to

<geshi lang="nginx">
    location /test {
        rewrite ^/test/(.*) /$1 break;
        proxy_pass http://my_backend;
    }
</geshi>

Note that it is not possible to use this interface to rewrite URI arguments and that [[#ngx.req.set_uri_args|ngx.req.set_uri_args]] should be used for this instead. For instance, Nginx config

<geshi lang="nginx">
    rewrite ^ /foo?a=3? last;
</geshi>

can be coded as

<geshi lang="nginx">
    ngx.req.set_uri_args("a=3")
    ngx.req.set_uri("/foo", true)
</geshi>

or

<geshi lang="nginx">
    ngx.req.set_uri_args({a = 3})
    ngx.req.set_uri("/foo", true)
</geshi>

This interface was first introduced in the <code>v0.3.1rc14</code> release.

== ngx.req.set_uri_args ==
'''syntax:''' ''ngx.req.set_uri_args(args)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Rewrite the current request's URI query arguments by the <code>args</code> argument. The <code>args</code> argument can be either a Lua string, as in

<geshi lang="lua">
    ngx.req.set_uri_args("a=3&b=hello%20world")
</geshi>

or a Lua table holding the query arguments' key-value pairs, as in

<geshi lang="lua">
    ngx.req.set_uri_args({ a = 3, b = "hello world" })
</geshi>

where in the latter case, this method will automatically escape argument keys and values according to the URI escaping rule.

Multi-value arguments are also supported:

<geshi lang="lua">
    ngx.req.set_uri_args({ a = 3, b = {5, 6} })
</geshi>

which will result in a querystring like <code>a=3&b=5&b=6</code>.

This interface was first introduced in the <code>v0.3.1rc13</code> release.

See also [[#ngx.req.set_uri|ngx.req.set_uri]].

== ngx.req.get_uri_args ==
'''syntax:''' ''args = ngx.req.get_uri_args(max_args?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holding all the current request URL query arguments.

<geshi lang="nginx">
    location = /test {
        content_by_lua '
            local args = ngx.req.get_uri_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>

Then <code>GET /test?foo=bar&bar=baz&bar=blah</code> will yield the response body

<geshi lang="bash">
    foo: bar
    bar: baz, blah
</geshi>

Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.

Keys and values are automatically unescaped according to URI escaping rules. In the settings above, <code>GET /test?a%20b=1%61+2</code> will yield:

<geshi lang="bash">
    a b: 1a 2
</geshi>

Arguments without the <code>=<value></code> parts are treated as boolean arguments. <code>GET /test?foo&bar</code> will yield:

<geshi lang="bash">
    foo: true
    bar: true
</geshi>

That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>GET /test?foo=&bar=</code> will give something like

<geshi lang="bash">
    foo: 
    bar: 
</geshi>

Empty key arguments are discarded. <code>GET /test?=hello&=world</code> will yield an empty output for instance.

Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime is also supported:

<geshi lang="lua">
    ngx.var.args = "a=3&b=42"
    local args = ngx.req.get_uri_args()
</geshi>

Here the <code>args</code> table will always look like

<geshi lang="lua">
    {a = 3, b = 42}
</geshi>

regardless of the actual request query string.

Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.

However, the optional <code>max_args</code> function argument can be used to override this limit:

<geshi lang="lua">
    local args = ngx.req.get_uri_args(10)
</geshi>

This argument can be set to zero to remove the limit and to process all request arguments received:

<geshi lang="lua">
    local args = ngx.req.get_uri_args(0)
</geshi>

Removing the <code>max_args</code> cap is strongly discouraged.

== ngx.req.get_post_args ==
'''syntax:''' ''ngx.req.get_post_args(max_args?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holding all the current request POST query arguments (of the MIME type <code>application/x-www-form-urlencoded</code>). Call [[#ngx.req.read_body|ngx.req.read_body]] to read the request body first or turn on the [[#lua_need_request_body|lua_need_request_body]] directive to avoid Lua exception errors.

<geshi lang="nginx">
    location = /test {
        content_by_lua '
            ngx.req.read_body()
            local args = ngx.req.get_post_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>

Then

<geshi lang="bash">
    # Post request with the body 'foo=bar&bar=baz&bar=blah'
    $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
</geshi>

will yield the response body like

<geshi lang="bash">
    foo: bar
    bar: baz, blah
</geshi>

Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be automatically unescaped according to URI escaping rules. 

With the settings above,

<geshi lang="bash">
    # POST request with body 'a%20b=1%61+2'
    $ curl -d 'a%20b=1%61+2' localhost/test
</geshi>

will yield:

<geshi lang="bash">
    a b: 1a 2
</geshi>

Arguments without the <code>=<value></code> parts are treated as boolean arguments. <code>GET /test?foo&bar</code> will yield:

<geshi lang="bash">
    foo: true
    bar: true
</geshi>

That is, they will take Lua boolean values <code>true</code>. However, they are different from arguments taking empty string values. <code>POST /test</code> with request body <code>foo=&bar=</code> will return something like

<geshi lang="bash">
    foo: 
    bar: 
</geshi>

Empty key arguments are discarded. <code>POST /test</code> with body <code>=hello&=world</code> will yield empty outputs for instance.

Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.  

However, the optional <code>max_args</code> function argument can be used to override this limit:

<geshi lang="lua">
    local args = ngx.req.get_post_args(10)
</geshi>

This argument can be set to zero to remove the limit and to process all request arguments received:

<geshi lang="lua">
    local args = ngx.req.get_post_args(0)
</geshi>

Removing the <code>max_args</code> cap is strongly discouraged.

== ngx.req.get_headers ==
'''syntax:''' ''headers = ngx.req.get_headers(max_headers?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holding all the current request headers.

<geshi lang="lua">
    local h = ngx.req.get_headers()
    for k, v in pairs(h) do
        ...
    end
</geshi>

To read an individual header:

<geshi lang="lua">
    ngx.say("Host: ", ngx.req.get_headers()["Host"])
</geshi>

Note that the [[#ngx.var.VARIABLE|ngx.var.HEADER]] API call, which uses core [[HttpCoreModule#$http_HEADER|$http_HEADER]] variables, may be more preferable for reading individual request headers.

For multiple instances of request headers such as:

<geshi lang="bash">
    Foo: foo
    Foo: bar
    Foo: baz
</geshi>

the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua (array) table such as:

<geshi lang="lua">
    {"foo", "bar", "baz"}
</geshi>

Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.  

However, the optional <code>max_headers</code> function argument can be used to override this limit:

<geshi lang="lua">
    local args = ngx.req.get_headers(10)
</geshi>

This argument can be set to zero to remove the limit and to process all request headers received:

<geshi lang="lua">
    local args = ngx.req.get_headers(0)
</geshi>

Removing the <code>max_headers</code> cap is strongly discouraged.

== ngx.req.set_header ==
'''syntax:''' ''ngx.req.set_header(header_name, header_value)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Set the current request's request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.
None of the current request's subrequests will be affected.

Here is an example of setting the <code>Content-Length</code> header:

<geshi lang="lua">
    ngx.req.set_header("Content-Type", "text/css")
</geshi>

The <code>header_value</code> can take an array list of values,
for example,

<geshi lang="lua">
    ngx.req.set_header("Foo", {"a", "abc"})
</geshi>

will produce two new request headers:

<geshi lang="bash">
    Foo: a
    Foo: abc
</geshi>

and old <code>Foo</code> headers will be overridden if there is any.

When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So

<geshi lang="lua">
    ngx.req.set_header("X-Foo", nil)
</geshi>

is equivalent to

<geshi lang="lua">
    ngx.req.clear_header("X-Foo")
</geshi>

== ngx.req.read_body ==
'''syntax:''' ''ngx.req.read_body()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Reads the client request body synchronously without blocking the Nginx event loop.

<geshi lang="lua">
    ngx.req.read_body()
    local args = ngx.req.get_post_args()
</geshi>

If the request body is already read previously by turning on [[#lua_need_request_body|lua_need_request_body]] or by using other modules, then this function does not run and returns immediately.

If the request body has already been explicitly discarded, either by the [[#ngx.req.discard_body|ngx.req.discard_body]] function or other modules, this function does not run and returns immediately.

In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception ''or'' terminate the current request with a 500 status code immediately.

The request body data read using this function can be retrieved later via [[#ngx.req.get_body_data|ngx.req.get_body_data]] or, alternatively, the temporary file name for the body data cached to disk using [[#ngx.req.get_body_file|ngx.req.get_body_file]]. This depends on

# whether the current request body is already larger than the [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]],
# and whether [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] has been switched on.

In cases where current request may have a request body and the request body data is not required, The [[#ngx.req.discard_body|ngx.req.discard_body]] function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.

This function was first introduced in the <code>v0.3.1rc17</code> release.

== ngx.req.discard_body ==
'''syntax:''' ''ngx.req.discard_body()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately. Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.

This function is an asynchronous call and returns immediately.

If the request body has already been read, this function does nothing and returns immediately.

This function was first introduced in the <code>v0.3.1rc17</code> release.

See also [[#ngx.req.read_body|ngx.req.read_body]].

== ngx.req.get_body_data ==
'''syntax:''' ''data = ngx.req.get_body_data()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Retrieves in-memory request body data. It returns a Lua string rather than a Lua table holding all the parsed query arguments. Use the [[#ngx.req.get_post_args|ngx.req.get_post_args]] function instead if a Lua table is required.

This function returns <code>nil</code> if
# the request body has not been read,
# the request body has been read into disk temporary files,
# or the request body has zero size.

If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body automatically, but this is not recommended).

If the request body has been read into disk files, try calling the [[#ngx.req.get_body_file|ngx.req.get_body_file]] function instead.

To force in-memory request bodies, try setting [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] to the same size value in [[HttpCoreModule#client_max_body_size|client_max_body_size]].

Note that calling this function instead of using <code>ngx.var.request_body</code> or <code>ngx.var.echo_request-body</code> is more efficient because it can save one dynamic memory allocation and one data copy.

This function was first introduced in the <code>v0.3.1rc17</code> release.

See also [[#ngx.req.get_body_file|ngx.req.get_body_file]].

== ngx.req.get_body_file ==
'''syntax:''' ''file_name = ngx.req.get_body_file()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Retrieves the file name for the in-file request body data. Returns <code>nil</code> if the request body has not been read or has been read into memory.

The returned file is read only and is usually cleaned up automatically by Nginx's memory pool. It should not be manually modified, renamed, or removed in Lua code.

If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body automatically, but this is not recommended).

If the request body has been read into memory, try calling the [[#ngx.req.get_body_data|ngx.req.get_body_data]] function instead.

To force in-file request bodies, try turning on [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].

This function was first introduced in the <code>v0.3.1rc17</code> release.

See also [[#ngx.req.get_body_data|ngx.req.get_body_data]].

== ngx.req.set_body_data ==
'''syntax:''' ''ngx.req.set_body_data(data)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Set the current request's request body using the in-memory data specified by the <code>data</code> argument.

If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.

This function requires patching the Nginx core to function properly because the Nginx core does not allow modifying request bodies by the current design. Here is a patch for Nginx 1.0.11: [https://github.com/agentzh/ngx_openresty/blob/master/patches/nginx-1.0.11-allow_request_body_updating.patch nginx-1.0.11-allow_request_body_updating.patch], and this patch should be applied cleanly to other releases of Nginx as well.

This patch has already been applied to [http://openresty.org/ ngx_openresty] 1.0.8.17 and above.

This function was first introduced in the <code>v0.3.1rc18</code> release.

See also [[#ngx.req.set_body_file|ngx.req.set_body_file]].

== ngx.req.set_body_file ==
'''syntax:''' ''ngx.req.set_body_file(file_name, auto_clean?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Set the current request's request body using the in-file data specified by the <code>file_name</code> argument.

If the optional <code>auto_clean</code> argument is given a <code>true</code> value, then this file will be automatically removed at request completion or the next time this function or [[#ngx.req.set_body_data|ngx.req.set_body_data]] are called in the same request. The <code>auto_clean</code> is default to <code>false</code>.

Please ensure that the file specified by the <code>file_name</code> argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.

If the current request's request body has not been read, then it will be properly discarded. When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.

This function requires patching the Nginx core to function properly because the Nginx core does not allow modifying request bodies by the current design. Here is a patch for Nginx 1.0.9: [https://github.com/agentzh/ngx_openresty/blob/master/patches/nginx-1.0.9-allow_request_body_updating.patch nginx-1.0.9-allow_request_body_updating.patch], and this patch should be applied cleanly to other releases of Nginx as well. 
This patch has already been applied to [http://openresty.org/ ngx_openresty] 1.0.8.17 and above.

This function was first introduced in the <code>v0.3.1rc18</code> release.

See also [[#ngx.req.set_body_data|ngx.req.set_body_data]].

== ngx.req.socket ==
'''syntax:''' ''tcpsock, err = ngx.req.socket()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Returns a read-only cosocket object that wraps the downstream connection. Only [[#tcpsock:receive|receive]] and [[#tcpsock:receiveuntil|receiveuntil]] methods are supported on this object.

In case of error, <code>nil</code> will be returned as well as a string describing the error.

The socket object returned by this method is usually used to read the current request's body in a streaming fashion. Do not turn on the [[#lua_need_request_body|lua_need_request_body]] directive, and do not mix this call with [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]].

If there is any request body data that has been preread into the Nginx core's request header buffer, the resulting cosocket object will take care of that automatically. So there will not be any data loss due to potential body data prereading.

This function was first introduced in the <code>v0.5.0rc1</code> release.

== ngx.req.clear_header ==
'''syntax:''' ''ngx.req.clear_header(header_name)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Clear the current request's request header named <code>header_name</code>. None of the current request's subrequests will be affected.

== ngx.exec ==
'''syntax:''' ''ngx.exec(uri, args?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Does an internal redirect to <code>uri</code> with <code>args</code>.

<geshi lang="lua">
    ngx.exec('/some-location');
    ngx.exec('/some-location', 'a=3&b=5&c=6');
    ngx.exec('/some-location?a=3&b=5', 'c=6');
</geshi>

Named locations are also supported, but query strings are ignored. For example,

<geshi lang="nginx">
    location /foo {
        content_by_lua '
            ngx.exec("@bar");
        ';
    }
 
    location @bar {
        ...
    }
</geshi>

The optional second <code>args</code> can be used to specify extra URI query arguments, for example:

<geshi lang="lua">
    ngx.exec("/foo", "a=3&b=hello%20world")
</geshi>

Alternatively, a Lua table can be passed for the <code>args</code> argument for ngx_lua to carry out URI escaping and string concatenation automatically.

<geshi lang="lua">
    ngx.exec("/foo", { a = 3, b = "hello world" })
</geshi>

The result is exactly the same as the previous example. The format for the Lua table passed as the <code>args</code> argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.

Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
it is just an internal redirect and no new HTTP traffic is involved.

This method never returns.

This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

It's strongly recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exec(...)</code>.

This method is similar to the [[HttpEchoModule#echo_exec|echo_exec]] directive of the [[HttpEchoModule]].

== ngx.redirect ==
'''syntax:''' ''ngx.redirect(uri, status?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue an <code>HTTP 301</code> or <code>302</code> redirection to <code>uri</code>.

The optional <code>status</code> parameter specifies whether
<code>301</code> or <code>302</code> to be used. It is <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.

Here is an example assuming the current server name is <code>localhost</code> and that it is listening on Port 1984:

<geshi lang="lua">
    return ngx.redirect("/foo")
</geshi>

which is equivalent to

<geshi lang="lua">
    return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
</geshi>

We can also use the numberical code directly as the second <code>status</code> argument:

<geshi lang="lua">
    return ngx.redirect("/foo", 301)
</geshi>

This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

This method never returns.

This method is very much like the [[HttpRewriteModule#rewrite|rewrite]] directive with the <code>redirect</code> modifier in the standard
[[HttpRewriteModule]], for example, this <code>nginx.conf</code> snippet

<geshi lang="nginx">
    rewrite ^ /foo? redirect;  # nginx config
</geshi>

is equivalent to the following Lua code

<geshi lang="lua">
    return ngx.redirect('/foo');  -- Lua code
</geshi>

while

<geshi lang="nginx">
    rewrite ^ /foo? permanent;  # nginx config
</geshi>

is equivalent to

<geshi lang="lua">
    return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
</geshi>

URI arguments can be specified as well, for example:

<geshi lang="lua">
    return ngx.redirect('/foo?a=3&b=4')
</geshi>

It's strongly recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.redirect(...)</code>.

== ngx.send_headers ==
'''syntax:''' ''ngx.send_headers()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly send out the response headers.

Note that there is normally no need to manually send out response headers as <code>ngx_lua</code> will automatically send headers out 
before content is output with [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] or when [[#content_by_lua|content_by_lua]] exits normally.

== ngx.headers_sent ==
'''syntax:''' ''value = ngx.headers_sent''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.

This API was first introduced in ngx_lua v0.3.1rc6.

== ngx.print ==
'''syntax:''' ''ngx.print(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Emits arguments concatenated to the HTTP client (as response body). If response headers have not been sent, this function will send headers out first and then output body data.

Lua <code>nil</code> values will output <code>"nil"</code> strings and Lua boolean values will output <code>"true"</code> and <code>"false"</code> literal strings respectively.

Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:

<geshi lang="lua">
    local table = {
        "hello, ",
        {"world: ", true, " or ", false,
            {": ", nil}}
    }
    ngx.print(table)
</geshi>

will yield the output

<geshi lang="bash">
    hello, world: true or false: nil
</geshi>

Non-array table arguments will cause a Lua exception to be thrown.

The <code>ngx.null</code> constant will yield the <code>"null"</code> string output.

This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer. To run in synchronous mode, call <code>ngx.flush(true)</code> after calling <code>ngx.print</code>. This can be particularly useful for streaming output. See [[#ngx.flush|ngx.flush]] for more details.

== ngx.say ==
'''syntax:''' ''ngx.say(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.

== ngx.log ==
'''syntax:''' ''ngx.log(log_level, ...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Log arguments concatenated to error.log with the given logging level.

Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code> string while Lua booleans result in literal <code>"true"</code> or <code>"false"</code> string outputs. And the <code>ngx.null</code> constant will yield the <code>"null"</code> string output.

The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [[#Nginx log level constants|Nginx log level constants]] for details.

There is a hard-coded length limitation on the error messages in the Nginx core. It is <code>2048</code> bytes at most, including the trailing newlines and the leading timestamps. You can manually modify this limit by modifying the <code>NGX_MAX_ERROR_STR</code> macro definition in the <code>src/core/ngx_log.h</code> file in the Nginx source tree. If the message size exceeds this limit, the Nginx core will truncate the message text automatically.

== ngx.flush ==
'''syntax:''' ''ngx.flush(wait?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Flushes response output to the client. 

<code>ngx.flush</code> accepts an optional boolean <code>wait</code> argument (Default: <code>false</code>) first introduced in the <code>v0.3.1rc34</code> release. When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer). Calling the function with the <code>wait</code> argument set to <code>true</code> switches to synchronous mode. 

In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [[HttpCoreModule#send_timeout|send_timeout]] setting has expired. Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.

When <code>ngx.flush(true)</code> is called immediately after [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]], it causes the latter functions to run in synchronous mode. This can be particularly useful for streaming output.

Note that <code>ngx.flush</code> is non functional when in the HTTP 1.0 output buffering mode. See [[#HTTP 1.0 support|HTTP 1.0 support]].

== ngx.exit ==
'''syntax:''' ''ngx.exit(status)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

When <code>status >= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.

When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [[#content_by_lua|content_by_lua]] directive is used) and continue to run later phases (if any) for the current request.

The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
<code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [[#HTTP status constants|HTTP status constants]].

To return an error page with custom contents, use code snippets like this:

<geshi lang="lua">
    ngx.status = ngx.HTTP_GONE
    ngx.say("This is our own content")
    -- to cause quit the whole request rather than the current phase handler
    ngx.exit(ngx.HTTP_OK)
</geshi>

The effect in action:

<geshi lang="bash">
    $ curl -i http://localhost/test
    HTTP/1.1 410 Gone
    Server: nginx/1.0.6
    Date: Thu, 15 Sep 2011 00:51:48 GMT
    Content-Type: text/plain
    Transfer-Encoding: chunked
    Connection: keep-alive

    This is our own content
</geshi>

Number literals can be used directly as the argument, for instance,

<geshi lang="lua">
    ngx.exit(501)
</geshi>

Note that while this method accepts all [[#HTTP status constants|HTTP status constants]] as input, it only accepts <code>NGX_OK</code> and <code>NGX_ERROR</code> of the [[#core constants|core constants]].

It's strongly recommended to combine the <code>return</code> statement with this call, i.e., <code>return ngx.exit(...)</code>.

== ngx.eof ==
'''syntax:''' ''ngx.eof()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly specify the end of the response output stream.

== ngx.escape_uri ==
'''syntax:''' ''newstr = ngx.escape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Escape <code>str</code> as a URI component.

== ngx.unescape_uri ==
'''syntax:''' ''newstr = ngx.unescape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Unescape <code>str</code> as an escaped URI component.

For example,

<geshi lang="lua">
    ngx.say(ngx.unescape_uri("b%20r56+7"))
</geshi>

gives the output

<geshi lang="text">
    b r56 7
</geshi>

== ngx.encode_args ==
'''syntax:''' ''str = ngx.encode_args(table)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Encode the Lua table to a query args string according to the URI encoded rules.

For example,

<geshi lang="lua">
    ngx.encode_args({foo = 3, ["b r"] = "hello world"})
</geshi>

yields

<geshi lang="text">
    foo=3&b%20r=hello%20world
</geshi>

The table keys must be Lua strings.

Multi-value query args are also supported. Just use a Lua table for the arg's value, for example:

<geshi lang="lua">
    ngx.encode_args({baz = {32, "hello"}})
</geshi>

gives

<geshi lang="text">
    baz=32&baz=hello
</geshi>

If the value table is empty and the effect is equivalent to the <code>nil</code> value.

Boolean argument values are also supported, for instance,

<geshi lang="lua">
    ngx.encode_args({a = true, b = 1})
</geshi>

yields

<geshi lang="text">
    a&b=1
</geshi>

If the argument value is <code>false</code>, then the effect is equivalent to the <code>nil</code> value.

This method was first introduced in the <code>v0.3.1rc27</code> release.

== ngx.decode_args ==
'''syntax:''' ''table = ngx.decode_args(str, max_args?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Decodes a URI encoded query-string into a Lua table. This is the inverse function of [[#ngx.encode_args|ngx.encode_args]].

The optional <code>max_args</code> argument can be used to specify the maximalnumber of arguments parsed from the <code>str</code> argument. By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.

This argument can be set to zero to remove the limit and to process all request arguments received:

<geshi lang="lua">
    local args = ngx.decode_args(str, 0)
</geshi>

Removing the <code>max_args</code> cap is strongly discouraged.

This method was introduced in the <code>v0.5.0rc29</code>.

== ngx.encode_base64 ==
'''syntax:''' ''newstr = ngx.encode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Encode <code>str</code> to a base64 digest.

== ngx.decode_base64 ==
'''syntax:''' ''newstr = ngx.decode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.

== ngx.crc32_short ==
'''syntax:''' ''intval = ngx.crc32_short(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.

This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [[#ngx.crc32_long|ngx.crc32_long]]. The result is exactly the same as [[#ngx.crc32_long|ngx.crc32_long]].

Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.

This API was first introduced in the <code>v0.3.1rc8</code> release.

== ngx.crc32_long ==
'''syntax:''' ''intval = ngx.crc32_long(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.

This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [[#ngx.crc32_short|ngx.crc32_short]].  The result is exactly the same as [[#ngx.crc32_short|ngx.crc32_short]].

Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.

This API was first introduced in the <code>v0.3.1rc8</code> release.

== ngx.hmac_sha1 ==
'''syntax:''' ''digest = ngx.hmac_sha1(secret_key, str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Computes the [http://en.wikipedia.org/wiki/HMAC HMAC-SHA1] digest of the argument <code>str</code> and turns the result using the secret key <code><secret_key></code>.

The raw binary form of the <code>HMAC-SHA1</code> digest will be generated, use [[#ngx.encode_base64|ngx.encode_base64]], for example, to encode the result to a textual representation if desired.

For example,

<geshi lang="lua">
    local key = "thisisverysecretstuff"
    local src = "some string we want to sign"
    local digest = ngx.hmac_sha1(key, src)
    ngx.say(ngx.encode_base64(digest))
</geshi>

yields the output

<geshi lang="text">
    R/pvxzHC4NLtj7S+kXFg/NePTmk=
</geshi>

This API requires the OpenSSL library enabled in the Nignx build (usually by passing the <code>--with-http_ssl_module</code> option to the <code>./configure</code> script).

This function was first introduced in the <code>v0.3.1rc29</code> release.

== ngx.md5 ==
'''syntax:''' ''digest = ngx.md5(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the hexadecimal representation of the MD5 digest of the <code>str</code> argument.

For example,

<geshi lang="nginx">
    location = /md5 {
        content_by_lua 'ngx.say(ngx.md5("hello"))';
    }
</geshi>

yields the output

<geshi lang="text">
    5d41402abc4b2a76b9719d911017c592
</geshi>

See [[#ngx.md5_bin|ngx.md5_bin]] if the raw binary MD5 digest is required.

== ngx.md5_bin ==
'''syntax:''' ''digest = ngx.md5_bin(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the binary form of the MD5 digest of the <code>str</code> argument.

See [[#ngx.md5|ngx.md5]] if the hexadecimal form of the MD5 digest is required.

== ngx.sha1_bin ==
'''syntax:''' ''digest = ngx.sha1_bin(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the binary form of the SHA-1 digest of the <code>str</code> argument.

This function requires enabling SHA-1 support in your Nginx build (usually you just need to install OpenSSL to your system while building Nginx).

This function was first introduced in the <code>v0.5.0rc6</code>.

== ngx.today ==
'''syntax:''' ''str = ngx.today()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns current date (in the format <code>yyyy-mm-dd</code>) from the nginx cached time (no syscall involved unlike Lua's date library).

This is the local time.

== ngx.time ==
'''syntax:''' ''secs = ngx.time()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the elapsed seconds from the epoch for the current timestamp from the nginx cached time (no syscall involved unlike Lua's date library).

Updates of the Nginx time cache an be forced by calling [[#ngx.update_time|ngx.update_time]] first.

== ngx.now ==
'''syntax:''' ''secs = ngx.now()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a floating-point number for the elapsed time in seconds (including microseconds as the decimal part) from the epoch for the current timestamp from the nginx cached time (no syscall involved unlike Lua's date library).

Use the Nginx core [[CoreModule#timer_resolution|timer_resolution]] directive to adjust the accuracy or forcibly update the Nginx time cache by calling [[#ngx.update_time|ngx.update_time]] first.

This API was first introduced in <code>v0.3.1rc32</code>.

== ngx.update_time ==
'''syntax:''' ''ngx.update_time()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Forcibly updates the Nginx current time cache. This call involves a syscall and thus has some overhead, so do not abuse it.

This API was first introduced in <code>v0.3.1rc32</code>.

== ngx.localtime ==
'''syntax:''' ''str = ngx.localtime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).

This is the local time.

== ngx.utctime ==
'''syntax:''' ''str = ngx.utctime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).

This is the UTC time.

== ngx.cookie_time ==
'''syntax:''' ''str = ngx.cookie_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a formated string can be used as the cookie expiration time. The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).

<geshi lang="nginx">
    ngx.say(ngx.cookie_time(1290079655))
        -- yields "Thu, 18-Nov-10 11:27:35 GMT"
</geshi>

== ngx.http_time ==
'''syntax:''' ''str = ngx.http_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).

<geshi lang="nginx">
    ngx.say(ngx.http_time(1290079655))
        -- yields "Thu, 18 Nov 10 11:27:35 GMT"
</geshi>

== ngx.parse_http_time ==
'''syntax:''' ''sec = ngx.parse_http_time(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Parse the http time string (as returned by [[#ngx.http_time|ngx.http_time]]) into seconds. Returns the seconds or <code>nil</code> if the input string is in bad forms.

<geshi lang="nginx">
    local time = ngx.parse_http_time("Thu, 18 Nov 10 11:27:35 GMT")
    if time == nil then
        ...
    end
</geshi>

== ngx.is_subrequest ==
'''syntax:''' ''value = ngx.is_subrequest''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.

== ngx.re.match ==
'''syntax:''' ''captures = ngx.re.match(subject, regex, options?, ctx?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Matches the <code>subject</code> string using the Perl-compatible regular expression <code>regex</code> with the optional <code>options</code>.

Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of fatal errors, like seeing bad <code>UTF-8</code> sequences in <code>UTF-8</code> mode, a Lua exception will be raised.

When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized subpattern's capturing, <code>captures[2]</code> the second, and so on.

<geshi lang="lua">
    local m = ngx.re.match("hello, 1234", "[0-9]+")
    -- m[0] == "1234"
</geshi>

<geshi lang="lua">
    local m = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
    -- m[0] == "1234"
    -- m[1] == "1"
</geshi>

Unmatched subpatterns will have <code>nil</code> values in their <code>captures</code> table fields.

<geshi lang="lua">
    local m = ngx.re.match("hello, world", "(world)|(hello)")
    -- m[0] == "hello"
    -- m[1] == nil
    -- m[2] == "hello"
</geshi>

Specify <code>options</code> to control how the match operation will be performed. The following option characters are supported:

<geshi lang="text">
    a             anchored mode (only match from the beginning)

    d             enable the DFA mode (or the longest token match semantics).
                  this requires PCRE 6.0+ or else a Lua exception will be thrown.
                  first introduced in ngx_lua v0.3.1rc30.

    i             caseless mode (similar to Perl's /i modifier)

    j             enable PCRE JIT compilation, this requires PCRE 8.21+ which
                  must be built with the --enable-jit option.
                  for optimum performance, this option should always be used  
                  together with the 'o' option.
                  first introduced in ngx_lua v0.3.1rc30.

    m             multi-line mode (similar to Perl's /m modifier)

    o             compile-once mode (similar to Perl's /o modifer),
                  to enable the worker-process-level compiled-regex cache

    s             single-line mode (similar to Perl's /s modifier)

    u             UTF-8 mode. this requires PCRE to be built with
                  the --enable-utf8 option or else a Lua exception will be thrown.

    x             extended mode (similar to Perl's /x modifier)
</geshi>

These options can be combined:

<geshi lang="nginx">
    local m = ngx.re.match("hello, world", "HEL LO", "ix")
    -- m[0] == "hello"
</geshi>

<geshi lang="nginx">
    local m = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
    -- m[0] == "hello, 美好"
    -- m[1] == "美好"
</geshi>

The <code>o</code> option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process. The upper limit of the regex cache can be tuned via the [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] directive.

The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset. Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position ''after'' the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will be left intact.

<geshi lang="lua">
    local ctx = {}
    local m = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
         -- m[0] = "1234"
         -- ctx.pos == 4
</geshi>

<geshi lang="lua">
    local ctx = { pos = 2 }
    local m = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
         -- m[0] = "34"
         -- ctx.pos == 4
</geshi>

The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.

Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified and that the empty Lua string (<code>""</code>) must be used as placeholder for <code>options</code> if no meaningful regex options are required.

This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).

To confirm that PCRE JIT is indeed enabled, it's required to enable the debugging logs in your Nginx build (by passing the <code>--with-debug</code> option to your Nginx or ngx_openresty's <code>./configure</code> script) and enable the "debug" error log level in your <code>error_log</code> directive, and then you can see the following message if PCRE JIT actually works:

<geshi lang="text">
    pcre JIT compiling result: 1
</geshi>

This feature was introduced in the <code>v0.2.1rc11</code> release.

== ngx.re.gmatch ==
'''syntax:''' ''iterator = ngx.re.gmatch(subject, regex, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Similar to [[#ngx.re.match|ngx.re.match]], but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the <code><subject></code> string argument with the PCRE <code>regex</code>.

Here is a small exmple to demonstrate its basic usage:

<geshi lang="lua">
    local iterator = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
    local m
    m = iterator()    -- m[0] == m[1] == "hello"
    m = iterator()    -- m[0] == m[1] == "world"
    m = iterator()    -- m == nil
</geshi>

More often we just put it into a Lua <code>for</code> loop:

<geshi lang="lua">
    for m in ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
        ngx.say(m[0])
        ngx.say(m[1])
    end
</geshi>

The optional <code>options</code> argument takes exactly the same semantics as the [[#ngx.re.match|ngx.re.match]] method.

The current implementation requires that the iterator returned should only be used in a single request. That is, one should ''not'' assign it to a variable belonging to persistent namespace like a Lua package.

This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).

This feature was first introduced in the <code>v0.2.1rc12</code> release.

== ngx.re.sub ==
'''syntax:''' ''newstr, n = ngx.re.sub(subject, regex, replace, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Substitutes the first match of the Perl-compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [[#ngx.re.match|ngx.re.match]].

This method returns the resulting new string as well as the number of successful substitutions, or throw out a Lua exception when an error occurred (syntax errors in the <code><replace></code> string argument, for example).

When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
        -- newstr == "hello, [12][1]34"
        -- n == 1
</geshi>

where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.

Curly braces can also be used to disambiguate variable names from the background string literals: 

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
        -- newstr == "hello, 10034"
        -- n == 1
</geshi>

Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "[0-9]", "$$")
        -- newstr == "hello, $234"
        -- n == 1
</geshi>

Do not use backlashes to escape dollar signs; it will not work as expected.

When the <code>replace</code> argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the <code>replace</code> function is exactly the same as the return value of [[#ngx.re.match|ngx.re.match]]. Here is an example:

<geshi lang="lua">
    local func = function (m)
        return "[" .. m[0] .. "][" .. m[1] .. "]"
    end
    local newstr, n = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
        -- newstr == "hello, [12][1]34"
        -- n == 1
</geshi>

The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.

This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).

This feature was first introduced in the <code>v0.2.1rc13</code> release.

== ngx.re.gsub ==
'''syntax:''' ''newstr, n = ngx.re.gsub(subject, regex, replace, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Just like [[#ngx.re.sub|ngx.re.sub]], but does global substitution.

Here is some examples:

<geshi lang="lua">
    local newstr, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
        -- newstr == "[hello,h], [world,w]"
        -- n == 2
</geshi>

<geshi lang="lua">
    local func = function (m)
        return "[" .. m[0] .. "," .. m[1] .. "]"
    end
    local newstr, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
        -- newstr == "[hello,h], [world,w]"
        -- n == 2
</geshi>

This method requires the PCRE library enabled in Nginx.  ([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).

This feature was first introduced in the <code>v0.2.1rc15</code> release.

== ngx.shared.DICT ==
'''syntax:''' ''dict = ngx.shared.DICT''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Fetching the shm-based Lua dictionary object for the shared memory zone named <code>DICT</code> defined by the [[#lua_shared_dict|lua_shared_dict]] directive.

The resulting object <code>dict</code> has the following methods:

* [[#ngx.shared.DICT.get|get]]
* [[#ngx.shared.DICT.set|set]]
* [[#ngx.shared.DICT.add|add]]
* [[#ngx.shared.DICT.replace|replace]]
* [[#ngx.shared.DICT.incr|incr]]
* [[#ngx.shared.DICT.delete|delete]]
* [[#ngx.shared.DICT.flush_all|flush_all]]

Here is an example:

<geshi lang="nginx">
    http {
        lua_shared_dict dogs 10m;
        server {
            location /set {
                content_by_lua '
                    local dogs = ngx.shared.dogs
                    dogs:set("Jim", 8)
                    ngx.say("STORED")
                ';
            }
            location /get {
                content_by_lua '
                    local dogs = ngx.shared.dogs
                    ngx.say(dogs:get("Jim"))
                ';
            }
        }
    }
</geshi>

Let us test it:

<geshi lang="bash">
    $ curl localhost/set
    STORED

    $ curl localhost/get
    8

    $ curl localhost/get
    8
</geshi>

The number <code>8</code> will be consistently output when accessing <code>/get</code> regardless of how many Nginx workers there are because the <code>dogs</code> dictionary resides in the shared memory and visible to ''all'' of the worker processes.

The shared dictionary will retain its contents through a server config reload (either by sending the <code>HUP</code> signal to the Nginx process or by using the <code>-s reload</code> command-line option).

The contents in the dictionary storage will be lost, however, when the Nginx server quits.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

== ngx.shared.DICT.get ==
'''syntax:''' ''value, flags = ngx.shared.DICT:get(key)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Retrieving the value in the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] for the key <code>key</code>. If the key does not exist or has been expired, then <code>nil</code> will be returned.

The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.

The first argument to this method must be the dictionary object itself, for example,

<geshi lang="lua">
    local cats = ngx.shared.cats
    local value, flags = cats.get(cats, "Marry")
</geshi>

or use Lua's syntactic sugar for method calls:

<geshi lang="lua">
    local cats = ngx.shared.cats
    local value, flags = cats:get("Marry")
</geshi>

These two forms are fundamentally equivalent.

If the user flags is <code>0</code> (the default), then no flags value will be returned.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.set ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Unconditionally sets a key-value pair into the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]]. Returns three values:

* <code>success</code>: boolean value to indicate whether the key-value pair is stored or not.
* <code>err</code>: textual error message, can be <code>"no memory"</code>.
* <code>forcible</code>: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.

The <code>value</code> argument inserted can be Lua booleans, numbers, strings, or <code>nil</code>. Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [[#ngx.shared.DICT.get|get]] method.

The optional <code>exptime</code> argument specifies expiration time (in seconds) for the inserted key-value pair. The time resolution is <code>0.001</code> seconds. If the <code>exptime</code> takes the value <code>0</code> (which is the default), then the item will never be expired.

The optional <code>flags</code> argument specifies a user flags value associated with the entry to be stored. It can also be retrieved later with the value. The user flags is stored as an unsigned 32-bit integer internally. Defaults to <code>0</code>. The user flags argument was first introduced in the <code>v0.5.0rc2</code> release.

When it fails to allocate memory for the current key-value item, then <code>set</code> will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over expiration time here. If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [[#lua_shared_dict|lua_shared_dict]] or memory segmentation), then the <code>err</code> return value will be <code>no memory</code> and <code>success</code> will be <code>false</code>.

If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the <code>forcible</code> return value will be <code>true</code>. If it stores the item without forcibly removing other valid items, then the return value <code>forcible</code> will be <code>false</code>.

The first argument to this method must be the dictionary object itself, for example,

<geshi lang="lua">
    local cats = ngx.shared.cats
    local succ, err, forcible = cats.set(cats, "Marry", "it is a nice cat!")
</geshi>

or use Lua's syntactic sugar for method calls:

<geshi lang="lua">
    local cats = ngx.shared.cats
    local succ, err, forcible = cats:set("Marry", "it is a nice cat!")
</geshi>

These two forms are fundamentally equivalent.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.add ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key does ''not'' exist.

If the <code>key</code> argument already exists in the dictionary (and not expired for sure), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"exists"</code>.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.replace ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key ''does'' exist.

If the <code>key</code> argument does ''not'' exist in the dictionary (or expired already), the <code>success</code> return value will be <code>false</code> and the <code>err</code> return value will be <code>"not found"</code>.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.delete ==
'''syntax:''' ''ngx.shared.DICT:delete(key)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Unconditionally removes the key-value pair from the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]].

It is equivalent to <code>ngx.shared.DICT:set(key, nil)</code>.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.incr ==
'''syntax:''' ''newval, err = ngx.shared.DICT:incr(key, value)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Increments the (numerical) value for <code>key</code> in the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] by the step value <code>value</code>. Returns the new resulting number if the operation is successfully completed or <code>nil</code> and an error message otherwise.

The key must already exist in the dictionary, otherwise it will return <code>nil</code> and <code>"not found"</code>.

If the original value is not a valid Lua number in the dictionary, it will return <code>nil</code> and <code>"not a number"</code>.

The <code>value</code> argument can be any valid Lua numbers, like negative numbers or floating-point numbers.

This feature was first introduced in the <code>v0.3.1rc22</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.shared.DICT.flush_all ==
'''syntax:''' ''ngx.shared.DICT:flush_all()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Flushes out all the items in the dictionary.

This feature was first introduced in the <code>v0.5.0rc17</code> release.

See also [[#ngx.shared.DICT|ngx.shared.DICT]].

== ngx.socket.tcp ==
'''syntax:''' ''tcpsock = ngx.socket.tcp()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Creates and returns a TCP (or Unix Domain) socket object (also known as the "cosocket" object). The following methods are supported on this object:

* [[#tcpsock:connect|connect]]
* [[#tcpsock:send|send]]
* [[#tcpsock:receive|receive]]
* [[#tcpsock:close|close]]
* [[#tcpsock:settimeout|settimeout]]
* [[#tcpsock:setoption|setoption]]
* [[#tcpsock:receiveuntil|receiveuntil]]
* [[#tcpsock:setkeepalive|setkeepalive]]
* [[#tcpsock:getreusedtimes|getreusedtimes]]

It is intended to be compatible with the TCP API of the [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] library but is 100% nonblocking out of the box. Also, we introduce some new APIs to provide more functionalities.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:connect ==
'''syntax:''' ''ok, err = tcpsock:connect(host, port)''

'''syntax:''' ''ok, err = tcpsock:connect("unix:/path/to/unix-domain.socket")''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Attempts to connect a TCP socket object to a remote server or to a unix domain socket file nonblockingly.

Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [[#ngx.socket.connect|ngx.socket.connect]] function).

Both IP addresses and domain names can be specified as the <code>host</code> argument. In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name nonblockingly and it is required to configure the [[HttpCoreModule#resolver|resolver]] directive in your <code>nginx.conf</code> file like this:

<geshi lang="nginx">
    resolver 8.8.8.8;  # use Google's public DNS nameserver
</geshi>

If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.

In case of error, the method returns <code>nil</code> followed by a string describing the error. In case of success, the method returns <code>1</code>.

Here is an example for connecting to a TCP server:

<geshi lang="nginx">
    location /test {
        resolver 8.8.8.8;

        content_by_lua '
            local sock = ngx.socket.tcp()
            local ok, err = sock:connect("www.google.com", 80)
            if not ok then
                ngx.say("failed to connect to google: ", err)
                return
            end
            ngx.say("successfully connected to google!")
            sock:close()
        ';
    }
</geshi>

Connecting to a Unix Domain Socket file is also possible:

<geshi lang="lua">
    local sock = ngx.socket.tcp()
    local ok, err = sock:connect("unix:/tmp/memcached.sock")
    if not ok then
        ngx.say("failed to connect to the memcached unix domain socket: ", err)
        return
    end
</geshi>

assuming that your memcached (or something else) is listening on the unix domain socket file <code>/tmp/memcached.sock</code>.

Timeout for the connecting operation is controlled by the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:

<geshi lang="lua">
    local sock = ngx.socket.tcp()
    sock:settimeout(1000)  -- one second timeout
    local ok, err = sock:connect(host, port)
</geshi>

It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.

Calling this method on an already connected socket object will cause the original connection to be closed first.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:send ==
'''syntax:''' ''bytes, err = tcpsock:send(data)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Sends data nonblockingly on the current TCP or Unix Domain Socket connection.

This method is a synchronous operation that will not return until ''all'' the data has been flushed into the system socket send buffer or an error occurs.

In case of success, it returns the total number of bytes that have been sent. Otherwise, it returns <code>nil</code> and a string describing the error.

The input argument `data` can either be a Lua string or a (nested) Lua table holding string fragments. In case of table arguments, this method will automatically copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.

Timeout for the sending operation is controlled by the [[#lua_socket_send_timeout|lua_socket_send_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:

<geshi lang="lua">
    sock:settimeout(1000)  -- one second timeout
    local bytes, err = sock:send(request)
</geshi>

It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:receive ==
'''syntax:''' ''data, err, partial = tcpsock:receive(size)''

'''syntax:''' ''data, err, partial = tcpsock:receive(pattern?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Receives data from the connected socket according to the reading pattern or size.

This method is a synchronous operation just like the [[#tcpsock:send|send]] method and is 100% nonblocking.

In case of success, it returns the data received; in case of error, it returns <code>nil</code> with a string describing the error and the partial data received so far.

If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size. This method will not return until it reads exactly this size of data or an error occurs.

If a non-number-like string argument is specified, then it is interpreted as a "pattern". The following patterns are supported:

* <code>'*a'</code>: reads from the socket until the connection is closed. No end-of-line translation is performed;
* <code>'*l'</code>: reads a line of text from the socket. The line is terminated by a <code>Line Feed</code> (LF) character (ASCII 10), optionally preceded by a <code>Carriage Return</code> (CR) character (ASCII 13). The CR and LF characters are not included in the returned line. In fact, all CR characters are ignored by the pattern.

If no argument is specified, then it is assumed to be the pattern <code>'*l'</code>, that is, the line reading pattern.

Timeout for the reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:

<geshi lang="lua">
    sock:settimeout(1000)  -- one second timeout
    local line, err, partial = sock:receive()
    if not line then
        ngx.say("failed to read a line: ", err)
        return
    end
    ngx.say("successfully read a line: ", line)
</geshi>

It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:receiveuntil ==
'''syntax:''' ''iterator = tcpsock:receiveuntil(pattern)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.

Here is an example for using this method to read a data stream with the boundary sequence <code>--abcedhb</code>:

<geshi lang="lua">
    local reader = sock:receiveuntil("\r\n--abcedhb")
    local data, err, partial = reader()
    if not data then
        ngx.say("failed to read the data stream: ", err)
    end
    ngx.say("read the data stream: ", data)
</geshi>

When called without any argument, the iterator function returns the received data right ''before'' the specified pattern string in the incoming data stream. So for the example above, if the incoming data stream is <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, then the string <code>'hello, world! -agentzh'</code> will be returned.

In case of error, the iterator function will return <code>nil</code> along with a string describing the error and the partial data bytes that have been read so far.

The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.

The iterator function behaves differently (i.e., like a real iterator) when it is called with a <code>size</code> argument. That is, it will read that <code>size</code> of data at earch invocation and will return <code>nil</code> at the last invocation (either sees the boundary pattern or meets an error). For the last successful invocation of the iterator function, the <code>err</code> return value will be <code>nil</code> too. The iterator function will automatically reset after its last successful invocation that returns <code>nil</code> data and <code>nil</code> error. Consider the following example:

<geshi lang="lua">
    local reader = sock:receiveuntil("\r\n--abcedhb")

    while true then
        local data, err, partial = reader(4)
        if not data then
            if err then
                ngx.say("failed to read the data stream: ", err)
                break
            end

            ngx.say("read done")
            break
        end
        ngx.say("read chunk: [", data, "]")
    end
</geshi>

Then for the incoming data stream <code>'hello, world! -agentzh\r\n--abcedhb blah blah'</code>, we shall get the following output from the sample code above:

<geshi lang="text">
    read chunk: [hell]
    read chunk: [o, w]
    read chunk: [orld]
    read chunk: [! -a]
    read chunk: [gent]
    read chunk: [zh]
    read done
</geshi>

Note that, the actual data returned ''might'' be a little longer than the size limit specified by the <code>size</code> argument when your boundary pattern has ambiguity for streaming parsing. Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.

Timeout for the iterator function's reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method. And the latter takes priority. For example:

<geshi lang="lua">
    local readline = sock:receiveuntil("\r\n")

    sock:settimeout(1000)  -- one second timeout
    line, err, partial = readline()
    if not line then
        ngx.say("failed to read a line: ", err)
        return
    end
    ngx.say("successfully read a line: ", line)
</geshi>

It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling the iterator function (note that the <code>receiveuntil</code> call is irrelevant here).

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:close ==
'''syntax:''' ''ok, err = tcpsock:close()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Closes the current TCP or Unix Domain socket. It returns the <code>1</code> in case of success and returns <code>nil</code> with a string describing the error otherwise.

For socket objects that have invoked the [[#tcpsock:setkeepalive|setkeepalive]] method, there is no need to call this method on it because the socket object is already closed (and the current connection is saved into the builtin connection pool).

For socket objects that have not invoked [[#tcpsock:setkeepalive|setkeepalive]], they (and their connections) will be automatically closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:settimeout ==
'''syntax:''' ''tcpsock:settimeout(time)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Set the timeout value in milliseconds for subsequent socket operations ([[#tcpsock:connect|connect]], [[#tcpsock:receive|receive]], and iterators returned from [[#tcpsock:receiveuntil|receiveuntil]]).

Settings done by this method takes priority over those config directives, i.e., [[#lua_socket_connect_timeout|lua_socket_connect_timeout]], [[#lua_socket_send_timeout|lua_socket_send_timeout]], and [[#lua_socket_read_timeout|lua_socket_read_timeout]].

Note that this method does ''not'' affect the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] setting; the <code>timeout</code> argument to the [[#tcpsock:setkeepalive|setkeepalive]] method should be used for this purpose instead.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:setoption ==
'''syntax:''' ''tcpsock:setoption(option, value?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This function is added for [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] API compatibility and does nothing for now. Its functionality will be implemented in future.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:setkeepalive ==
'''syntax:''' ''ok, err = tcpsock:setkeepalive(timeout?, size?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Puts the current socket's connection into the cosocket built-in connection pool and keep it alive until other [[#tcpsock:connect|connect]] method calls request it or the associated maximal idle timeout is expired.

The first optional argument, <code>timeout</code>, can be used to specify the maximal idle timeout (in milliseconds) for the current connection. If omitted, the default setting in the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] config directive will be used. If the <code>0</code> value is given, then the timeout interval is unlimited.

The second optional argument, <code>size</code>, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path). Note that the size of the connection pool cannot be changed once the pool is created. When this argument is omitted, the default setting in the [[#lua_socket_pool_size|lua_socket_pool_size]] config directive will be used.

When the connection pool is exceeding the size limit, the least recently used (idle) connection already in the pool will be closed automatically to make room for the current connection.

Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.

Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.

In case of success, this method returns <code>1</code>; otherwise, it returns <code>nil</code> and a string describing the error.

This method also makes the current cosocket object enter the "closed" state, so you do not need to manually call the [[#tcpsock:close|close]] method on it afterwards.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== tcpsock:getreusedtimes ==
'''syntax:''' ''count, err = tcpsock:getreusedtimes()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This method returns the (successfully) reused times for the current connection. In case of error, it returns <code>nil</code> and a string describing the error.

If the current connection does not come from the built-in connection pool, then this method always returns <code>0</code>, that is, the connection has never been reused (yet). If the connection comes from the connection pool, then the return value is always non-zero. So this method can also be used to determine if the current connection comes from the pool.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== ngx.socket.connect ==
'''syntax:''' ''tcpsock, err = ngx.socket.connect(host, port)''

'''syntax:''' ''tcpsock, err = ngx.socket.connect("unix:/path/to/unix-domain.socket")''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

This function is a shortcut for combining [[#ngx.socket.tcp|ngx.socket.tcp()]] and the [[#tcpsock:connect|connect()]] method call in a single operation. It is actually implemented like this:

<geshi lang="lua">
    local sock = ngx.socket.tcp()
    local ok, err = sock:connect(...)
    if not ok then
        return nil, err
    end
    return sock
</geshi>

There is no way to use the [[#tcpsock:settimeout|settimeout]] method to specify connecting timeout for this method. You have to use the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] directive at configure time instead.

This feature was first introduced in the <code>v0.5.0rc1</code> release.

== ndk.set_var.DIRECTIVE ==
'''syntax:''' ''res = ndk.set_var.DIRECTIVE_NAME''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

This mechanism allows calling other nginx C modules' directives that are implemented by [https://github.com/simpl/ngx_devel_kit Nginx Devel Kit] (NDK)'s set_var submodule's <code>ndk_set_var_value</code>.

For example, the following [[HttpSetMiscModule]] directives can be invoked this way:

* [[HttpSetMiscModule#set_quote_sql_str|set_quote_sql_str]]
* [[HttpSetMiscModule#set_quote_pgsql_str|set_quote_pgsql_str]]
* [[HttpSetMiscModule#set_quote_json_str|set_quote_json_str]]
* [[HttpSetMiscModule#set_unescape_uri|set_unescape_uri]]
* [[HttpSetMiscModule#set_escape_uri|set_escape_uri]]
* [[HttpSetMiscModule#set_encode_base32|set_encode_base32]]
* [[HttpSetMiscModule#set_decode_base32|set_decode_base32]]
* [[HttpSetMiscModule#set_encode_base64|set_encode_base64]]
* [[HttpSetMiscModule#set_decode_base64|set_decode_base64]]
* [[HttpSetMiscModule#set_encode_base64|set_encode_hex]]
* [[HttpSetMiscModule#set_decode_base64|set_decode_hex]]
* [[HttpSetMiscModule#set_encode_base64|set_sha1]]
* [[HttpSetMiscModule#set_decode_base64|set_md5]]

For instance,

<geshi lang="lua">
    local res = ndk.set_var.set_escape_uri('a/b');
    -- now res == 'a%2fb'
</geshi>

Similarly, the following directives provided by [[HttpEncryptedSessionModule]] can be invoked from within Lua too:

* [[HttpEncryptedSessionModule#set_encrypt_session|set_encrypt_session]]
* [[HttpEncryptedSessionModule#set_decrypt_session|set_decrypt_session]]

This feature requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

= HTTP 1.0 support =

The HTTP 1.0 protocol does not support chunked outputs and always requires an
explicit <code>Content-Length</code> header when the response body is non-empty in order to support the HTTP 1.0 keep-alive (as required by the ApacheBench (ab) tool). So when
an HTTP 1.0 request is present and the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned <code>on</code>, this module will automatically buffer all the
outputs of user calls of [[#ngx.say|ngx.say]] and [[#ngx.print|ngx.print]] and
postpone sending response headers until it sees all the outputs in the response
body, and at that time ngx_lua can calculate the total length of the body and
construct a proper <code>Content-Length</code> header for the HTTP 1.0 client.

If the user Lua code sets the <code>Content-Length</code> response header itself, then the automatic buffering will be disabled even if the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned <code>on</code>.

For big responses' streaming outputs, it's important to disable the [[#lua_http10_buffering|lua_http10_buffering]] directive, otherwise the memory usage will grow very quickly.

Note that, common HTTP benchmark tools like <code>ab</code> and <code>http_load</code> always issue
HTTP 1.0 requests by default. To force <code>curl</code> to send HTTP 1.0 requests, use
the <code>-0</code> option.

= Data Sharing within an Nginx Worker =

'''NOTE: This mechanism behaves differently when code cache is turned off and should be considered a DIRTY TRICK. Note that backward compatibility is NOT guaranteed and that there may be other undesirable consequences. A new data sharing mechanism will be designed later.'''

To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua <code>require</code> builtin to import the module, and then manipulate the shared data in Lua. This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module. Note however that Lua global variables WILL NOT persist between requests because of the one-coroutine-per-request isolation design.

Here is a complete small example:

<geshi lang="lua">
    -- mydata.lua
    module("mydata", package.seeall)
 
    local data = {
        dog = 3,
        cat = 4,
        pig = 5,
    }
 
    function get_age(name)
        return data[name]
    end
</geshi>

and then accessing it from <code>nginx.conf</code>:

<geshi lang="nginx">
    location /lua {
        content_lua_by_lua '
            local mydata = require("mydata")
            ngx.say(mydata.get_age("dog"))
        ';
    }
</geshi>

The <code>mydata</code> module in this example will only be loaded and run on the first request to the location <code>/lua</code>,
and all subsequent requests to the same nginx worker process will use the reloaded instance of the
module as well as the same copy of the data in it, until a <code>HUP</code> signal is sent to the Nginx master process to force a reload.
This data sharing technique is essential for high performance Lua applications based on this module.

Note that this data sharing is on a ''per-worker'' basis and not on a ''per-server' basis'. That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers. 

If server wide data sharing is required:
# Use the [[#ngx.shared.DICT|ngx.shared.DICT]] API provied by this module.
# Use only a single nginx worker and a single server. This is however not recommended when there is a multi core CPU or multiple CPUs in a single machine.
# Use data storage mechanisms such as <code>memcached</code>, <code>redis</code>, <code>MySQL</code> or <code>PostgreSQL</code>. [http://openresty.org The ngx_openresty bundle] associated with this module comes with a set of companion Nginx modules that provide interfaces with these data storage mechanisms.  See the [[HttpMemcModule]], [[HttpRedis2Module]], [[HttpDrizzleModule]] and [http://github.com/FRiCKLE/ngx_postgres/ HttpPostgresModule] modules for details

= Known Issues =

== Lua Coroutine Yielding/Resuming ==
* As the module's predefined Nginx I/O API uses the coroutine yielding/resuming mechanism, user code should not call any Lua modules that use the Lua coroutine mechanism in order to prevent conflicts with the module's predefined Nginx API methods such as [[#ngx.location.capture|ngx.location.capture]] (Actually, coroutine modules have been masked off in [[#content_by_lua|content_by_lua]] directives and others). This limitation is significant and work is ongoing on an alternative coroutine implementation that can fit into the Nginx event model to address this. When this is done, it will be possible to use the Lua coroutine mechanism freely as it is in standard Lua implementations.
* Lua's <code>dofile</code> builtin is implemented as a C function in both Lua 5.1 and LuaJIT 2.0 and when [[#ngx.location.capture|ngx.location.capture]] is called, [[#ngx.exec|ngx.exec]], [[#ngx.exit|ngx.exit]] or [[#ngx.req.read_body|ngx.req.read_body]] or similar in the file to be loaded by <code>dofile</code>, a coroutine yield across the C function boundary will be initiated. This however is not allowed within ngx_lua and will usually result in error messages like <code>lua handler aborted: runtime error: attempt to yield across C-call boundary</code>. To avoid this, define a real Lua module and use the Lua <code>require</code> builtin instead.
* Because the standard Lua 5.1 interpreter's VM is not fully resumable, the methods [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], and [[#ngx.exit|ngx.exit]] cannot be used within the context of a Lua [http://www.lua.org/manual/5.1/manual.html#pdf-pcall pcall()] or [http://www.lua.org/manual/5.1/manual.html#pdf-xpcall xpcall()] when the standard Lua 5.1 interpreter is used and the <code>attempt to yield across metamethod/C-call boundary</code> error will be produced. Please use LuaJIT 2.0, which supports a fully resumable VM, to avoid this.

== Lua Variable Scope ==
Care should be taken when importing modules and this form should be used:

<geshi lang="nginx">
        local xxx = require('xxx')
</geshi>

: instead of the old deprecated form:

<geshi lang="nginx">
        require('xxx')
</geshi>

: If the old form is required, force reload the module for every request by using the <code>package.loaded.<module></code> command:

<geshi lang="nginx">
        package.loaded.xxx = nil
        require('xxx')
</geshi>

It is recommended to always place the following piece of code at the end of Lua modules that use the [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] directives to prevent casual use of module-level global variables that are shared among ''all'' requests:

<geshi lang="nginx">
    getmetatable(foo.bar).__newindex = function (table, key, val)
        error('Attempt to write to undeclared variable "' .. key .. '": '
                .. debug.traceback())
    end
</geshi>

Assuming the current Lua module is named <code>foo.bar</code>, this will guarantee that local variables in module <code>foo.bar</code> functions have been declared as "local". It prevents undesirable race conditions while accessing such variables. See [[#Data_Sharing_within_an_Nginx_Worker|Data Sharing within an Nginx Worker]] for the reasons behind this.

== Locations Configured by Subrequest Directives of Other Modules ==
The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] directives cannot capture locations that include the [[HttpEchoModule#echo_location|echo_location]], [[HttpEchoModule#echo_location_async|echo_location_async]], [[HttpEchoModule#echo_subrequest|echo_subrequest]], or [[HttpEchoModule#echo_subrequest_async|echo_subrequest_async]] directives.

<geshi lang="nginx">
    location /foo {
        content_by_lua '
            res = ngx.location.capature("/bar")
        ';
    }
    location /bar {
        echo_location /blah;
    }
    location /blah {
        echo "Success!";
    }
</geshi>

<geshi lang="nginx">
    $ curl -i http://example.com/foo
</geshi>

will not work as expected.

== Special PCRE Sequences ==
PCRE sequences such as <code>\d</code>, <code>\s</code>, or <code>\w</code>, require special attention because in string literals, the backslash character, <code>\</code>, is stripped out by both the Lua language parser and by the Nginx config file parser before processing. So the following snippet will not work as expected:

<geshi lang="nginx">
    # nginx.conf
    ? location /test {
    ?     content_by_lua '
    ?         local regex = "\d+"  -- THIS IS WRONG!!
    ?         local m = ngx.re.match("hello, 1234", regex)
    ?         if m then ngx.say(m[0]) else ngx.say("not matched!") end
    ?     ';
    ? }
    # evaluates to "not matched!"
</geshi>

To avoid this, ''double'' escape the backslash:

<geshi lang="nginx">
    # nginx.conf
    location /test {
        content_by_lua '
            local regex = "\\\\d+"
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        ';
    }
    # evaluates to "1234"
</geshi>

Here, <code>\\\\d+</code> is stripped down to <code>\\d+</code> by the Nginx config file parser and this is further stripped down to <code>\d+</code> by the Lua language parser before running.

Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in "long brackets", <code>&#91;[...]]</code>, in which case backslashes have to only be escaped once for the Nginx config file parser. 

<geshi lang="nginx">
    # nginx.conf
    location /test {
        content_by_lua '
            local regex = [[\\d+]]
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        ';
    }
    # evaluates to "1234"
</geshi>

Here, <code>&#91;[\\d+]]</code> is stripped down to <code>&#91;[\d+]]</code> by the Nginx config file parser and this is processed correctly.

Note that a longer from of the long bracket, <code>[=[...]=]</code>, may be required if the regex pattern contains <code>&#91;...]</code> sequences. 
The <code>[=[...]=]</code> form may be used as the default form if desired and it may help with readability if a space is inserted between the long brackets and the regex patterns.

<geshi lang="nginx">
    # nginx.conf
    location /test {
        content_by_lua '
            local regex = [=[ [0-9]+ ]=]
            local m = ngx.re.match("hello, 1234", regex)
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        ';
    }
    # evaluates to "1234"
</geshi>

An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various <code>*_by_lua_file</code> directives. 
With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.

<geshi lang="lua">
    -- test.lua
    local regex = "\\d+"
    local m = ngx.re.match("hello, 1234", regex)
    if m then ngx.say(m[0]) else ngx.say("not matched!") end
    -- evaluates to "1234"
</geshi>

Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification. 
 
<geshi lang="lua">
    -- test.lua
    local regex = [[\d+]]
    local m = ngx.re.match("hello, 1234", regex)
    if m then ngx.say(m[0]) else ngx.say("not matched!") end
    -- evaluates to "1234"
</geshi>

= Typical Uses =

Just to name a few:

* Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
* doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,
* manipulating response headers in an arbitrary way (by Lua)
* fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,
* coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,
* doing very complex URL dispatch in Lua at rewrite phase,
* using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.

The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user. The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint. This is particularly the case when LuaJIT 2.0 is enabled. 

Other scripting language implementations typically struggle to match this performance level.

The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to miminize memory use.

On a ThinkPad T400 2.80 GHz laptop, the HelloWorld example readily achieves 28k req/sec using <code>http_load -p 10</code>. By contrast, Nginx + php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and [http://nodejs.org/ Node.js] v0.6.1 yields 10.2k req/sec for their HelloWorld equivalents.

This module performs best when built with [http://luajit.org/luajit.html LuaJIT 2.0].

= Nginx Compatibility =
The module is compatible with the following versions of Nginx:

*   1.1.x (last tested: 1.1.5)
*   1.0.x (last tested: 1.0.15)
*   0.9.x (last tested: 0.9.4)
*   0.8.x >= 0.8.54 (last tested: 0.8.54)

= Code Repository =

The code repository of this project is hosted on github at [http://github.com/chaoslawful/lua-nginx-module chaoslawful/lua-nginx-module].

= Installation =

The [http://openresty.org ngx_openresty bundle] can be used to install Nginx, <code>ngx_lua</code>, either one of the standard Lua 5.1 interpreter or LuaJIT 2.0, as well as a package of powerful companion Nginx modules. The basic installation step is a simple <code>./configure --with-luajit && make && make install</code>.

Alternatively, <code>ngx_lua</code> can be manually compiled into Nginx:

# Install LuaJIT 2.0 (Recommended) or Lua 5.1 (Lua 5.2 is ''not'' supported yet). Lua can be obtained free from the [http://luajit.org/download.html the LuaJIT download page] or [http://www.lua.org/ the standard Lua homepage].  Some distribution package managers also distribute Lua and LuaJIT.
# Download the latest version of the ngx_devel_kit (NDK) module [http://github.com/simpl/ngx_devel_kit/tags HERE].
# Download the latest version of this module [http://github.com/chaoslawful/lua-nginx-module/tags HERE].
# Download the latest version of Nginx [http://nginx.org/ HERE] (See [[#Nginx Compatibility|Nginx Compatibility]])

Build the source with this module:

<geshi lang="bash">
    wget 'http://nginx.org/download/nginx-1.0.15.tar.gz'
    tar -xzvf nginx-1.0.15.tar.gz
    cd nginx-1.0.15/
 
    # tell nginx's build system where to find lua:
    export LUA_LIB=/path/to/lua/lib
    export LUA_INC=/path/to/lua/include
 
    # or tell where to find LuaJIT when if using JIT instead
    # export LUAJIT_LIB=/path/to/luajit/lib
    # export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
 
    # Here we assume Nginx is to be installed under /opt/nginx/.
    ./configure --prefix=/opt/nginx \
            --add-module=/path/to/ngx_devel_kit \
            --add-module=/path/to/lua-nginx-module
 
    make -j2
    make install
</geshi>

= Bugs and Patches =

Please report bugs or submit patches by:

# Creating a ticket on the [http://github.com/chaoslawful/lua-nginx-module/issues GitHub Issue Tracker] (Recommended)
# Posting to the [http://mailman.nginx.org/mailman/listinfo/nginx Nginx Mailing List] and also adding <code>[ngx_lua]</code> to the mail subject.

= TODO =

== Short Term ==
* implement the <code>ngx.sleep(time)</code> Lua API. (For now, use [[#ngx.location.capture|ngx.location.capture]] with [[HttpEchoModule]]'s [[HttpEchoModule#echo_sleep|echo_sleep]] config directive instead.)
* implement the <code>ngx.worker.get_pid()</code> Lua API. (For now, use <code>ngx.var.pid</code> directly.)
* implement [http://w3.impa.br/~diego/software/luasocket/udp.html LuaSocket UDP API] in our cosocket API.
* implement the SSL cosocket API.
* implement the <code>ngx.re.split</code> method.
* use <code>ngx_hash_t</code> to optimize the built-in header look-up process for [[#ngx.req.set_header|ngx.req.set_header]], [[#ngx.header.HEADER|ngx.header.HEADER]], and etc.
* add configure options for different strategies of handling the cosocket connection exceeding in the pools.
* add directives to run Lua codes when nginx stops/reloads.
* add APIs to access cookies as key/value pairs.
* add <code>ignore_resp_headers</code>, <code>ignore_resp_body</code>, and <code>ignore_resp</code> options to [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] methods, to allow micro performance tuning on the user side.

== Longer Term ==
* add the <code>lua_require</code> directive to load module into main thread's globals.
* add Lua code automatic time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.
* make [[#set_by_lua|set_by_lua]], [[#header_filter_by_lua|header_filter_by_lua]], and their variants use the same mechanism as [[#content_by_lua|content_by_lua]], [[#rewrite_by_lua|rewrite_by_lua]], [[#access_by_lua|access_by_lua]], and their variants.
* add coroutine API back to the Lua user land.
* add <code>stat</code> mode similar to [http://httpd.apache.org/docs/2.3/mod/mod_lua.html mod_lua].

= Changes =

== v0.4.1 ==

1 February, 2012

* bugfix: [[#ngx.exit|ngx.exit]], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], and [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]] could return (they should never return as per the documentation). this bug had appeared in ngx_lua v0.3.1rc4 and ngx_openresty 1.0.6.13. thanks [http://weibo.com/cyberty @cyberty] for reporting it.
* bugfix: <code>ngx_http_lua_header_filter_init</code> was called with an argument which actually accepts none. this could cause compilation errors at least with gcc 4.3.4 as reported in [http://github.com/chaoslawful/lua-nginx-module/issues/80 github issue #80]. thanks bigplum (Simon).
* bugfix: fixed all the warnings from the clang static analyzer.
* feature: allow use of the <code>DDEBUG</code> macro from the outside (via the <code>-D DDEBUG=1</code> C compiler opton).

== v0.4.0 ==

11 January, 2012

* bugfix: fixed a bug when the both the main request and the subrequest are POST requests with a body: we should not forward the main request's <code>Content-Length</code> headers to the user subrequests. thanks 朱峰.
* feature: implemented the API for reading response headers from within Lua: <code>value = ngx.header.HEADER</code>, see [[#ngx.header.HEADER|ngx.header.HEADER]].
* bugfix: fixed a bug when setting a multi-value response header to a single value (via writing to [[#ngx.header.HEADER|ngx.header.HEADER]]): the single value will be repeated on each old value.
* bugfix: fixed an issue in [[#ngx.redirect|ngx.redirect]], [[#ngx.exit|ngx.exit]], and [[#ngx.exec|ngx.exec]]: these function calls would be intercepted by Lua <code>pcall</code>/<code>xpcall</code> because they used Lua exceptions; now they use Lua yield just as [[#ngx.location.capture|ngx.location.capture]]. thanks @hugozhu for reporting this.
* feature: now we also return the <code>Last-Modified</code> header (if any) for the subrequest response object. thanks @cyberty and sexybabes.
* feature: now [[#ngx.exec|ngx.exec]] supports Lua table as the second args argument value. thanks sexybabes.
* feature: implemented the [[#ngx.headers_sent|ngx.headers_sent]] API to check if response headers are sent (by ngx_lua). thanks @hugozhu.
* feature: exposes the CRC-32 API of the Nginx core to the Lua land, in the form of the [[#ngx.crc32_short|ngx.crc32_short]] and [[#ngx.crc32_long|ngx.crc32_long]] methods. thanks @Lance.
* feature: now for HTTP 1.0 requests, we disable the automatic full buffering mode if the user sets the <code>Content-Length</code> response header before sending out the headers. this allows streaming output for HTTP 1.0 requests if the content length can be calculated beforehand. thanks 李子义.
* bugfix: now we properly support setting the <code>Cache-Control</code> response header via the [[#ngx.header.HEADER|ngx.header.HEADER]] interface.
* bugfix: no longer set header hash to <code>1</code>. use the <code>ngx_hash_key_lc</code> instead.
* bugfix: calling [[#ngx.exec|ngx.exec]] to jump to a named location did not clear the context object of LuaNginxModule properly and might cause evil problems. thanks Nginx User.
* bugfix: now we explicitly clear all the modules' contexts before dump to named location with [[#ngx.exec|ngx.exec]].
* feature: implemented [[#ngx.req.set_uri|ngx.req.set_uri]] and [[#ngx.req.set_uri_args|ngx.req.set_uri_args]] to emulate [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive. thanks Vladimir Protasov (utros) and Nginx User.
* bugfix: now we skip rewrite phase Lua handlers altogether if [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive issue a location re-lookup by changing URIs (but not including <code>rewrite ... break</code>). thanks Nginx User.
* feature: added constant <code>ngx.HTTP_METHOD_NOT_IMPLEMENTED (501)</code>. thanks Nginx User.
* feature: added new Lua functions [[#ngx.req.read_body|ngx.req.read_body]], [[#ngx.req.discard_body|ngx.req.discard_body]], [[#ngx.req.get_body_data|ngx.req.get_body_data]], and [[#ngx.req.get_body_file|ngx.req.get_body_file]]. thanks Tzury Bar Yochay for funding the development work.
* bugfix: fixed hanging issues when using [[#ngx.exec|ngx.exec]] within [[#rewrite_by_lua|rewrite_by_lua]] and [[#access_by_lua|access_by_lua]]. thanks Nginx User for reporting it.
* feature: added new Lua API [[#ngx.req.set_body_file|ngx.req.set_body_file]]. thanks Tzury Bar Yochay for funding the development work.
* feature: added new Lua API [[#ngx.req.set_body_data|ngx.req.set_body_data]]. thanks Tzury Bar Yochay for funding the development work.
* bugfix: [[#lua_need_request_body|lua_need_request_body]] should not skip requests with methods other than <code>POST</code> and <code>PUT</code>. thanks Nginx User.
* bugfix: no longer free request body buffers that are not allocated by ourselves.
* bugfix: now we allow setting [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] to nil.
* feature: added new directive [[#lua_shared_dict|lua_shared_dict]].
* feature: added Lua API for the shm-based dictionary, see [[#ngx.shared.DICT|ngx.shared.DICT]].
* bugfix: fixed spots of -Werror=unused-but-set-variable warning issued by gcc 4.6.0.
* bugfix: [[#ndk.set_var.DIRECTIVE|ndk.set_var.DIRECTIVE]] had a memory issue and might pass empty argument values to the directive being called. thanks dannynoonan.
* feature: added the <code>ctx</code> option to [[#ngx.location.capture|ngx.location.capture]]: you can now specify a custom Lua table to pass to the subrequest as its [[#ngx.ctx|ngx.ctx]]. thanks @hugozhu.
* feature: added the [[#ngx.encode_args|ngx.encode_args]] method to encode a Lua code to a URI query string. thanks 郭颖 (0597虾).
* feature: [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.exec|ngx.exec]] now supports the same Lua args table format as in ngx.encode_args. thanks 郭颖 (0597虾).
* bugfix: <code>Cache-Control</code> header modification might introduce empty value headers when using with the standard HttpHeadersModule.
* feature: added [[#ngx.hmac_sha1|ngx.hmac_sha1]]. thanks drdrxp.
* docs: documented the long-existent [[#ngx.md5|ngx.md5]] and [[#ngx.md5_bin|ngx.md5_bin]] APIs.
* docs: massive documentation improvements. thanks Nginx User.
* feature: added new regex options <code>j</code> and <code>d</code> to [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] so as to enable the PCRE JIT mode and DFA mode, respectively. thanks @姜大炮 for providing the patch.
* feature: added options <code>copy_all_vars</code> and <code>vars</code> to [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]]. thanks Marcus Clyne for the patch.
* feature: added new Lua API [[#ngx.now|ngx.now]] to return the current time (including the milliseconds part as the decimal part). thanks 林青.
* feature: added new Lua API [[#ngx.update_time|ngx.update_time]] to forcibly updating Nginx's time cache.
* feature: added <code>wait</code> boolean argument to [[#ngx.flush|ngx.flush]] to support synchronous flushing: <code>ngx.flush(true)</code> will not return until all the data has been flushed into the system send buffer or the send timeout has expired.
* bugfix: now we check timed out downstream connections in our write event handler.
* feature: added constant <code>ngx.HTTP_GATEWAY_TIMEOUT (504)</code> per Fry-kun in [https://github.com/chaoslawful/lua-nginx-module/issues/73 github issue #73].
* bugfix: [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] did not evaluate to <code>nil</code> when the Nginx variable's <code>valid</code> flag is <code>0</code>.
* bugfix: there were various places where we did not check the pointer returned by the memory allocator.
* bugfix: [[#ngx.req.set_header|ngx.req.set_header]] and [[#ngx.req.clear_header|ngx.req.clear_header]] did not handle the <code>Accept-Encoding</code> request headers properly. thanks 天街夜色.
* bugfix: [[#ngx.req.set_header|ngx.req.set_header]] might cause invalid memory reads because Nginx request header values must be <code>NULL</code> terminated. thanks Maxim Dounin.
* bugfix: removing builtin headers via [[#ngx.req.clear_header|ngx.req.clear_header]] and its equivalent in huge request headers with 20+ entries could result in data loss. thanks Chris Dumoulin.
* bugfix: [[#ngx.req.get_uri_args|ngx.req.get_uri_args]] and [[#ngx.req.get_post_args|ngx.req.get_post_args]] now only parse up to <code>100</code> arguments by default. but one can specify the optional argument to these two methods to specify a custom maximum number of args. thanks Tzury Bar Yochay for reporting this.
* bugfix: [[#ngx.req.get_headers|ngx.req.get_headers]] now only parse up to <code>100</code> request headers by default. but one can specify the optional argument to this method to specify a custom maximum number of headers.

== v0.3.0 ==

September 02, 2011

'''New features'''

* added the [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]] directives. thanks Liseen Wan (万珣新).
* implemented the PCRE regex API for Lua: [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]].
* now we add the <code>ngx</code> and <code>ndk</code> table into <code>package.loaded</code> such that the user can write <code>local ngx = require 'ngx'</code> and <code>local ndk = require 'ndk'</code>. thanks @Lance.
* added new directive [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] to control the upper limit of the worker-process-level compiled-regex cache enabled by the <code>o</code> regex option.
* implemented the special [[#ngx.ctx|ngx.ctx]] Lua table for user programmers to store per-request Lua context data for their applications. thanks 欧远宁 for suggesting this feature.
* now [[#ngx.print|ngx.print]] and [[#ngx.say|ngx.say]] allow (nested) array-like table arguments. the array elements in them will be sent piece by piece. this will avoid string concatenation for templating engines like [http://www.savarese.com/software/ltp/ ltp].
* implemented the [[#ngx.req.get_post_args|ngx.req.get_post_args]] method for fetching url-encoded POST query arguments from within Lua.
* implemented the [[#ngx.req.get_uri_args|ngx.req.get_uri_args]] method to fetch parsed URL query arguments from within Lua. thanks Bertrand Mansion (golgote).
* added new function [[#ngx.parse_http_time|ngx.parse_http_time]], thanks James Hurst.
* now we allow Lua boolean and <code>nil</code> values in arguments to [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], [[#ngx.log|ngx.log]] and [[#print|print]].
* added support for user C macros <code>LUA_DEFAULT_PATH</code> and <code>LUA_DEFAULT_CPATH</code>. for now we can only define them in <code>ngx_lua</code>'s <code>config</code> file because nginx <code>configure</code>'s <code>--with-cc-opt</code> option hates values with double-quotes in them. sigh. This feature is used by [http://openresty.org The ngx_openresty bundle] to bundle third party Lua libraries.

'''Bug fixes'''

* worked-around the "stack overflow" issue while using <code>luarocks.loader</code> and disabling [[#lua_code_cache|lua_code_cache]], as described as github issue #27. thanks Patrick Crosby.
* fixed the <code>zero size buf in output</code> alert while combining [[#lua_need_request_body|lua_need_request_body]] on + [[#access_by_lua|access_by_lua]]/[[#rewrite_by_lua|rewrite_by_lua]] + [[HttpProxyModule#proxy_pass|proxy_pass]]/[[HttpFcgiModule#fastcgi_pass|fastcgi_pass]]. thanks Liseen Wan (万珣新).
* fixed issues with HTTP 1.0 HEAD requests.
* made setting <code>ngx.header.HEADER</code> after sending out response headers throw out a Lua exception to help debugging issues like github issue #49. thanks Bill Donahue (ikhoyo).
* fixed an issue regarding defining global variables in C header files: we should have defined the global <code>ngx_http_lua_exception</code> in a single compilation unit. thanks @姜大炮.

= Test Suite =

The following dependencies are required to run the test suite:

* Nginx version >= 0.8.54

* Perl modules:
** test-nginx: http://github.com/agentzh/test-nginx 

* Nginx modules:
** echo-nginx-module: http://github.com/agentzh/echo-nginx-module 
** drizzle-nginx-module: http://github.com/chaoslawful/drizzle-nginx-module 
** rds-json-nginx-module: http://github.com/agentzh/rds-json-nginx-module 
** set-misc-nginx-module: http://github.com/agentzh/set-misc-nginx-module 
** headers-more-nginx-module: http://github.com/agentzh/headers-more-nginx-module 
** memc-nginx-module: http://github.com/agentzh/memc-nginx-module 
** srcache-nginx-module: http://github.com/agentzh/srcache-nginx-module 
** ngx_auth_request: http://mdounin.ru/hg/ngx_http_auth_request_module/ 

* C libraries:
** yajl: https://github.com/lloyd/yajl 

* Lua modules:
** lua-yajl: https://github.com/brimworks/lua-yajl 
*** Note: the compiled module has to be placed in '/usr/local/lib/lua/5.1/'

* Applications:
** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
** memcached

The order in which these modules are added during configuration is important as the position of any filter module in the
filtering chain determines the final output. The correct adding order is:

# ngx_devel_kit
# set-misc-nginx-module
# ngx_http_auth_request_module
# echo-nginx-module
# memc-nginx-module
# lua-nginx-module (i.e. this module)
# headers-more-nginx-module
# srcache-nginx-module
# drizzle-nginx-module
# rds-json-nginx-module

= Copyright and License =

This module is licensed under the BSD license.

Copyright (C) 2009-2012, by Xiaozhe Wang (chaoslawful) <chaoslawful@gmail.com>.

Copyright (C) 2009-2012, by Zhang "agentzh" Yichun (章亦春) <agentzh@gmail.com>.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

= See Also =

* [http://github.com/agentzh/lua-resty-memcached lua-resty-memcached] library based on ngx_lua cosocket.
* [http://github.com/agentzh/lua-resty-redis lua-resty-redis] library based on ngx_lua cosocket.
* [http://github.com/agentzh/lua-resty-mysql lua-resty-mysql] library based on ngx_lua cosocket.
* [http://github.com/agentzh/lua-resty-upload lua-resty-upload] library based on ngx_lua cosocket.
* [http://github.com/agentzh/lua-resty-string lua-resty-string] library based on [http://luajit.org/ext_ffi.html LuaJIT FFI].
* [http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs Routing requests to different MySQL queries based on URI arguments]
* [http://openresty.org/#DynamicRoutingBasedOnRedis Dynamic Routing Based on Redis and Lua]
* [http://openresty.org/#UsingLuaRocks Using LuaRocks with ngx_lua]
* [https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction Introduction to ngx_lua]
* [http://github.com/simpl/ngx_devel_kit ngx_devel_kit]
* [[HttpEchoModule]]
* [[HttpDrizzleModule]]
* [http://github.com/FRiCKLE/ngx_postgres postgres-nginx-module]
* [[HttpMemcModule]]
* [http://openresty.org The ngx_openresty bundle]

= Translations =
* [[HttpLuaModuleZh|Chinese]]

